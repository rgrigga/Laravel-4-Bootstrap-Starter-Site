/**
 * jscolor, JavaScript Color Picker
 *
 * @version 1.4.0
 * @license GNU Lesser General Public License, http://www.gnu.org/copyleft/lesser.html
 * @author  Jan Odvarko, http://odvarko.cz
 * @created 2008-06-15
 * @updated 2012-07-06
 * @link    http://jscolor.com
 */

eval("/*global define:false */\ndefine('lib/extend',[],function() {\n  var extend=function (a,b){for(var c in b.prototype)c in a.prototype||(a.prototype[c]=b.prototype[c])};\n  return extend;\n});\n//@ sourceURL=/lib/extend.js"),eval("/*global $:false */\n/*global define:false */\n/*global setTimeout:false */\ndefine('lib/emitter',[],function() {\n  \n  var Emitter = {\n    on: function(path, callback, once) {\n      if (typeof path == 'string') {\n        path = new RegExp('^' + path + '$');\n      }\n      var wrapped_callback = function() {\n        var ctx = this, args = arguments;\n\n        return setTimeout(function() {\n          callback.apply(ctx, args);\n        }, 0);\n      };\n      var handler = {path: path, callback: wrapped_callback, once: once};\n      if (!this._handlers) { this._handlers = []; }\n      this._handlers.push(handler);\n      return this;\n    },\n\n    once: function(path, callback) {\n      return this.on(path, callback, true);\n    },\n\n    emit: function() {\n      var ctx = this,\n      args = $.makeArray(arguments),\n      path = args.shift();\n    \n      if (this._handlers) {\n        var i = 0, l = this._handlers.length, handler;\n        for (; i < l; i++) {\n          handler = this._handlers[i];\n          if (handler && handler.path.test(path)) {\n            if (handler.once) { this._handlers.splice(i, 1); }\n            handler.callback.apply(ctx, args);\n          }\n        }\n      }\n      return this;\n    }\n\n  };\n\n  return Emitter;\n\n});\n//@ sourceURL=/lib/emitter.js"),eval('/*global $:false */\n/*global define:false */\n/*global document:false */\n/*global window:false */\ndefine(\'graph_editor/graph_editor\',[\'lib/extend\',\'lib/emitter\'],function(extend, Emitter) {\n  \n  /*\n  \n  GraphEditor\n  ===================================\n  \n    - Initialization\n  \n    - User Issued Commands\n    \n    - Helpers\n    \n    - GraphObject\n    \n    - Load and Save\n    \n    - RunTime Communication\n    \n    - Layers\n    \n    - Node and Plugin Registation\n  \n  =================================== */\n  \n  var GraphEditor = {\n\n    patchList: {}, // make this an array\n\n    //comments: [], // move this to the patch at some point...\n\n    nodeTypes: {}, // make this an array\n    nodeTypeAliases: {}, // make this an array\n    commandHistoryList: [],\n    commandFutureList:[],\n    pluginTypes:{}, // make this an array\n    runtimeList:{}, // make this an array\n    \n    /*\n    \n    Initialization\n    \n    ============== */\n\n    init: function(options) {\n      this.createMainElement();\n      this.createStage();\n      this.createMenu();\n      this.setupEventHandlers();\n      this.loadPlugins(options.plugins);\n      this.setupRootPatch();\n      //ge = this;\n    },\n\n    createMainElement: function() {\n      this.$element = $(\'<div id="graph_editor">\');\n      this.$element.appendTo($(document.body));\n    },\n\n    createStage: function() {\n      \n      this.$stage = $(\'<div id="stage">\');\n      this.$stage.appendTo(this.$element);\n      this.$stage.css({\n        width: $(document).width(),\n        height: $(document).height()\n      });\n      \n      $(".header").css({\n        position: "fixed",\n        top: 0,\n        "z-index": 10000,\n        width: "100%"\n      });\n      \n      var $dnd = $(\'<div />\');\n      $dnd.addClass(\'drag-n-drop\');\n      $dnd.text("Drag and drop images on background");\n      \n    },\n\n    createMenu: function() {\n      this.$menu = $("<div />");\n      this.$menu.css({\n        position: "fixed",\n        top: 0,\n        left: 0,\n        width: "100%",\n        "background-color": "#ddd",\n        "font-family": "Arial"\n      });\n\n      $("#graph_editor").append(this.$menu);\n    },\n\n    setupEventHandlers: function() {\n      \n      var that = this;\n      \n      // Deselect nodes\n      this.$stage.on("mousedown", function() {\n        that.deselectAll();\n      });\n      this.$stage.on("touchstart", function() {\n        that.deselectAll();\n      });\n\n      // Listen for keyboard events\n      $(window).on("keyup", function(evt) {\n        if (GraphEditor.modalWindowOpen) {\n          return;\n        }\n        if (evt.keyCode == 80 && evt.ctrlKey) { // p\n          GraphEditor.createPatch();\n        }\n      });\n\n      $(window).resize(function() {\n        GraphEditor.resize();\n      }).resize();\n      \n      $(document).mousemove(function(event) {\n        GraphEditor.mouseX = event.pageX;\n        GraphEditor.mouseY = event.pageY;\n      });\n      \n      GraphEditor.on("nodeMoved", function(node) {\n        that.moveNode(node);\n      });\n\n      // An incoming event from a runtime worker      \n      GraphEditor.on("triggerRunTimeEvents", function(events) {\n        for (var i = 0; i < events.length; i++) {\n          var event = events[i];\n          var node = GraphEditor.findNodeById(event.node_id);\n          if (node) {\n            node.events[event.name](event.event);\n          } \n        }\n      });\n\n      // RunTime Loading\n      GraphEditor.on("runTimesDidLoad", function() {\n        if (!this._pluginsNeedRunTime) {\n          GraphEditor.emit("graphEditorDidLoad");\n          return;\n        }\n        for (var i=0; i < this._pluginsNeedRunTime.length; i++) {\n          var plugin_option = this._pluginsNeedRunTime[i];\n          var plugin_name = plugin_option.name;\n          this.pluginTypes[plugin_name].init(this);\n        }\n        GraphEditor.emit("graphEditorDidLoad");\n      });\n      GraphEditor.on("imageLoaded", function() {\n        that.imagesLoaded++;\n        if (that.imagesLoaded == that.imageUrlsOnLoad) {\n          GraphEditor.emit("projectLoaded");\n        }\n      });\n      GraphEditor.on("registerRunTime", function(json_event) {\n        var event = JSON.parse(json_event);\n        GraphEditor.runtimeList[event.name] = event;\n      });\n      \n      // Layer events\n      GraphEditor.on("reorderNodes", function(node_ids) {\n        GraphEditor.reorderNodes(node_ids);\n      });\n      \n      // Edge drawing management\n      GraphEditor.on("edgeIsDrawing", function() {\n        that.edgeIsDrawing = true;\n      });\n      GraphEditor.on("edgeEndDrawing", function() {\n        that.edgeIsDrawing = false;\n      });\n      \n    },\n\n    loadPlugins: function(plugin_options) {\n      this._pluginsNeedRunTime = [];\n      for (var i=0; i < plugin_options.length; i++) {\n        var plugin_option = plugin_options[i];\n        var plugin_name = plugin_option.name;\n        if (plugin_option.needsRunTimeOptions) {\n          this._pluginsNeedRunTime.push(plugin_option);\n        }\n        else {\n          if (this.pluginTypes[plugin_name] && this.pluginTypes[plugin_name].init) {\n            this.pluginTypes[plugin_name].init(this);\n          }\n          else {\n            //console.error("Could not load plugin: ", plugin_name);\n          }\n        }\n\n      }\n    },\n\n    setupRootPatch: function() {\n      this.rootPatch = new GraphEditor.Patch({\n        id: "root"\n      });\n      this.currentPatch = this.rootPatch;\n      this.currentPatch.show();\n    },\n    \n    /*\n    \n    User Issued Commands\n    \n    ==================== */\n\n    connect: function(options) {\n      var edge;\n      new GraphEditor.Command({\n        name: "connect",\n        exec: function() {\n          edge = GraphEditor.connectFunc(options);\n        },\n        undo: function() {\n          edge.remove();\n        }\n      });\n      return edge;\n    },\n    \n    connectFunc: function(edge_options) {\n      var source = GraphEditor.findNodeById(edge_options.source_id);\n      var destination = GraphEditor.findNodeById(edge_options.destination_id);\n      if (!source) {\n        return;\n      }\n      var edge = source.connect(destination, edge_options.output_name, edge_options.input_name);\n      return edge;\n    },\n\n    disconnect: function(edge) {\n      var editor = this;\n      new GraphEditor.Command({\n        name: "disconnect",\n        exec: function() {\n          edge.remove();\n        },\n        undo: function() {\n          var source = editor.findNodeById(edge.source.id);\n          var destination = editor.findNodeById(edge.destination.id);\n          var output_name = edge.output_name;\n          var input_name = edge.input_name;\n          source.connect(destination, output_name, input_name);\n        }\n      });\n    },\n    \n    createComment: function(options) {\n      var comment = new GraphEditor.Comment(options);\n      return comment;\n    },\n\n    createNode: function(options) { \n      options = $.extend({}, options);\n      var node;\n      new GraphEditor.Command({\n        name: "createNode",\n        exec: function() {\n          node = GraphEditor.createNodeFunc(options);\n        },\n        undo: function() {\n          node = GraphEditor.findNodeById(options.id);\n          node.remove();\n        }\n      });\n      return node;    \n    },\n    \n    createNodeFunc: function(node_options) {\n      if (this.nodeTypeAliases[node_options.type]) {\n        node_options.type = this.nodeTypeAliases[node_options.type];\n      }\n      if (!node_options.id) {\n        node_options.id = parseInt(Math.random(1)*10000000,10).toString(); // this should be replaced with something better\n      }\n      var nodeCreateFunction;\n      if (this.nodeTypes[node_options.type]) {\n        nodeCreateFunction = this.nodeTypes[node_options.type];\n      }\n      else {\n        nodeCreateFunction = GraphEditor.Node;\n      }\n      var node = new nodeCreateFunction(node_options);\n      this.updateLayeredNodeCount();\n      this.deselectAll();\n      return node;\n    },\n    \n    removeNodes: function(nodes, edges) {\n      \n      var ordered_nodes = [];\n      var all_nodes = this.allNodes();\n      \n      for (var i = 0; i < all_nodes.length; i++) {\n        var o_node = all_nodes[i];\n        for (var j = 0; j < nodes.length; j++) {\n          var u_node = nodes[j];\n          if (o_node.id == u_node.id) {\n            ordered_nodes.push(o_node);\n          }\n        }\n      }\n      \n      if (!edges && ordered_nodes.length == 1) {\n        edges = ordered_nodes[0].edges;\n      }\n      \n      this.createGraphObject(ordered_nodes, edges, function(graph_object) {\n        \n        new GraphEditor.Command({\n          name: "removeNodes",\n          exec: function() {\n            for (var i = 0; i < graph_object.nodes.length; i++) {\n              var node_options = graph_object.nodes[i];\n              var node = GraphEditor.findNodeById(node_options.id);\n              node.remove();\n            }\n          },\n          undo: function() {\n            GraphEditor.initGraphObject(graph_object);\n          }\n        });\n        \n      });\n\n    },\n    \n    moveNode: function(node) {\n      var node_id = node.id;\n      var x = node.getX();\n      var y = node.getY();\n      var previous_x = node.x;\n      var previous_y = node.y;\n      new GraphEditor.Command({\n        name: "moveNode",\n        exec: function() {\n          var node = GraphEditor.findNodeById(node_id);\n          node.moveTo(x, y);\n          node.patch.redrawEdges();\n        },\n        undo: function() {\n          var node = GraphEditor.findNodeById(node_id);\n          node.moveTo(previous_x, previous_y);\n          node.patch.redrawEdges();\n        }\n      });\n      GraphEditor.resize();\n    },\n    \n    setWorkerAttributeFromInput: function(input, value, previous_value, preview) {\n\n      if (preview) {\n        var options = {\n          runtime: input.node.runtime,\n          worker_id: input.node.id,\n          input_name: input.name,\n          value: value\n        };\n        var json_options = JSON.stringify(options);\n        GraphEditor.emit("setWorkerAttribute", json_options);\n      }\n      else {\n        new GraphEditor.Command({\n          name: "setWorkerAttributeFromInput",\n          exec: function() {\n            var options = {\n              runtime: input.node.runtime,\n              worker_id: input.node.id,\n              input_name: input.name,\n              value: value\n            };\n            var json_options = JSON.stringify(options);\n            GraphEditor.emit("setWorkerAttribute", json_options);\n          },\n          undo: function() {\n            var options = {\n              runtime: input.node.runtime,\n              worker_id: input.node.id,\n              input_name: input.name,\n              value: previous_value\n            };\n            var json_options = JSON.stringify(options);\n            GraphEditor.emit("setWorkerAttribute", json_options);\n          }\n        });\n      }\n\n    },\n    \n    loadGraphObject: function(graph_object) {\n      \n      graph_object = $.extend(true, {}, graph_object);\n      \n      new GraphEditor.Command({\n        name: "loadGraphObject",\n        exec: function() {\n          GraphEditor.initGraphObject(graph_object);\n        },\n        undo: function() {\n          GraphEditor.removeGraphObject(graph_object);\n        }\n      });\n      \n    },\n\n    createPatch: function() {\n\n      var patch_node = new GraphEditor.PatchNode({\n        "type":"patch",\n        "x":700,"y":200,\n        "patch": this.currentPatch.id\n      });\n\n      var patch = patch_node.containedPatch;\n\n      var i;\n      for (i=0; i < this.currentPatch.selectedNodes.length; i++) {\n        var selected_node = this.currentPatch.selectedNodes[i];\n        selected_node.patch.nodeList.splice(selected_node.patch.nodeList.indexOf(selected_node), 1);\n        patch.nodeList.push(selected_node);\n        //selected_node.group.moveTo(patch.nodeLayer);\n        selected_node.patch = patch;\n        if (selected_node.type == "patch") {\n          selected_node.containedPatch.parent = selected_node.patch;\n        }\n      }\n\n      var incomingEdges = [];\n      var outgoingEdges = [];\n\n      for (i=0; i < this.currentPatch.selectedEdges.length; i++) {\n        var selected_edge = this.currentPatch.selectedEdges[i];\n\n        var source_index = this.currentPatch.selectedNodes.indexOf(selected_edge.source);\n        var destination_index = this.currentPatch.selectedNodes.indexOf(selected_edge.destination);\n\n        if (source_index == -1) {\n          incomingEdges.push(selected_edge);\n        }\n\n        if (destination_index == -1) {\n          outgoingEdges.push(selected_edge);\n        }\n\n        selected_edge.patch.edgeList.splice(selected_edge.patch.edgeList.indexOf(selected_edge), 1);\n        patch.edgeList.push(selected_edge);\n        //selected_edge.line.moveTo(patch.edgeLayer);\n        //selected_edge.targetArea.moveTo(patch.edgeLayer);\n\n        selected_edge.patch = patch;\n\n      }\n\n      var edge;\n      for (i=0; i < incomingEdges.length; i++) {\n        edge = incomingEdges[i];\n        edge.remove();\n      }\n\n      for (i=0; i < outgoingEdges.length; i++) {\n        edge = outgoingEdges[i];\n        edge.remove();\n      }\n\n      this.deselectAll();\n\n    },\n    \n    deselectAll: function() {\n      for (var i in GraphEditor.patchList) {\n        var patch = GraphEditor.patchList[i];\n        patch.deselectAll();\n      }\n    },\n\n    clearAll: function() {\n      this.deselectAll();\n      var nodes = this.allNodes();\n      for (var i in nodes) {\n        var node = nodes[i];\n        for (var j = 0; j < node.edges.length; j++) {\n          var edge = node.edges[j];\n          edge.remove();\n        }\n        node.remove();\n      }\n      //this.comments = [];\n      this.worker_attributes = [];\n      GraphEditor.emit("clearAll");\n    },\n    \n    /*\n    \n    Helpers\n    \n    ======= */\n    \n    findEdgeByInput: function(input) {\n      for (var patch_name in this.patchList) {\n        var patch = this.patchList[patch_name];\n        var edge = patch.findEdgeByInput(input);\n        if (edge) {\n          return edge;\n        }\n      }\n    },\n    \n    findEdge: function(edge_options) {\n      var edges = this.allEdges();\n      for (var i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        if (edge.source.id == edge_options.source_id && edge.destination.id == edge_options.destination_id && edge.input_name == edge_options.input_name && edge.output_name == edge_options.output_name) {\n          return edge; \n        }\n      }\n    },\n    \n    findNodeById: function(node_id) {\n      for (var patch_name in this.patchList) {\n        var patch = this.patchList[patch_name];\n        var node = patch.findNodeById(node_id);\n        if (node) {\n          return node;\n        }\n      }\n    },\n    \n    allNodes: function() {\n      var nodes = [];\n      for (var patch_name in this.patchList) {\n        var patch = this.patchList[patch_name];\n        nodes = nodes.concat(patch.allNodes());\n      }\n      return nodes;\n    },\n    \n    allEdges: function() {\n      var edges = [];\n      for (var patch_name in this.patchList) {\n        var patch = this.patchList[patch_name];\n        edges = edges.concat(patch.allEdges());\n      }\n      return edges;\n    },\n    \n    commentAttributes: function(comment) {\n      comment.options.x = comment.x;\n      comment.options.y = comment.y;\n      return $.extend({}, comment.options);\n    },\n\n    nodeAttributes: function(node) {\n      node.options.x = node.x;\n      node.options.y = node.y;\n      node.options.fade_in = null;\n      return $.extend({}, node.options);\n    },\n    \n    edgeAttributes: function(edge) {\n      var edge_attributes = {\n        destination_id: edge.destination.id,\n        input_name: edge.input_name,\n        source_id: edge.source.id,\n        output_name: edge.output_name\n      };\n      return edge_attributes;\n    },\n    \n    resize: function() {\n      this.$stage.css({\n        width: $(document).width(),\n        height: $(document).height()\n      });\n      for (var i in this.patchList) {\n        var patch = this.patchList[i];\n        patch.resize();\n      }\n    },\n    \n    /*\n    \n    GraphObject\n    \n    =========== */\n    \n    createGraphObject: function(nodes, edges, callback) {\n      \n      var graph_object;\n      graph_object = {};        \n      graph_object.nodes = [];\n      graph_object.edges = [];\n      //graph_object.comments = [];\n      graph_object.worker_attributes = {};\n      \n      if (nodes.length > 0) {\n        \n        var nodeMap = {};\n        \n        for (i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          var node_options = GraphEditor.nodeAttributes(node);\n          nodeMap[node.id] = true;\n          graph_object.nodes.push(node_options);\n        }\n        \n        for (var i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n          \n          if (edges.indexOf(edge) != i) {\n            continue; // skip duplicate edges\n          }\n          \n          var edge_option = GraphEditor.edgeAttributes(edge);\n          var source_id = edge_option.source_id;\n          var destination_id = edge_option.destination_id;\n          \n          if (nodeMap[source_id] && nodeMap[destination_id]) {\n            graph_object.edges.push(edge_option);\n          }\n          \n        }\n        \n        GraphEditor.emit("getAllWorkersAttributes");\n        GraphEditor.once("gotAllWorkersAttributes", function(json_worker_attributes) {\n\n          var worker_attributes = JSON.parse(json_worker_attributes);\n          \n          for (var runtime_name in worker_attributes) {\n            graph_object.worker_attributes[runtime_name] = [];\n            var runtime_worker_attributes = worker_attributes[runtime_name];\n            for (var k = 0; k < runtime_worker_attributes.length; k++) {\n              var worker_attribute = runtime_worker_attributes[k];\n              if (nodeMap[worker_attribute.id]) {\n                graph_object.worker_attributes[runtime_name].push(worker_attribute);\n              }\n            }\n          }\n          \n          callback(graph_object);\n\n        });\n        \n      }\n      else {\n        callback(graph_object);\n      }\n      \n    },\n    \n    initGraphObject: function(graph_object) {\n      \n      graph_object = $.extend(true, {}, graph_object);\n      \n      var nodes = graph_object.nodes;\n      var i;\n      for (i = 0; i < nodes.length; i++) {\n        var node_options = nodes[i];\n        console.log(node_options.id);\n        GraphEditor.createNodeFunc(node_options);   \n      }\n      var edges = graph_object.edges;\n      for (i = 0; i < edges.length; i++) {\n        var edge_options = edges[i];\n        GraphEditor.connectFunc(edge_options);\n      }\n      \n      $(".node").css("z-index", 20);\n      this.updateLayeredNodeCount();\n      \n      // var comments = graph_object.comments;\n      // for (i = 0; i < comments.length; i++) {\n      //   var comment_options = comments[i];\n      // }\n\n      var worker_attributes = graph_object.worker_attributes;\n      GraphEditor.emit("setAllWorkerAttributes", JSON.stringify(worker_attributes));\n    },\n    \n    removeGraphObject: function(graph_object) {\n      var nodes = graph_object.nodes;\n      var i;\n      for (i = 0; i < nodes.length; i++) {\n        var node_options = nodes[i];\n        var node = GraphEditor.findNodeById(node_options.id);\n        node.remove();\n      }\n      var edges = graph_object.edges;\n      for (i = 0; i < edges.length; i++) {\n        var edge_options = edges[i];\n        var edge = GraphEditor.findEdge(edge_options);\n        edge.remove();\n      }\n      $(".node").css("z-index", 20);\n      this.updateLayeredNodeCount();\n    },\n    \n    /*\n    \n    Load and Save\n    \n    ============= */\n\n    stringify: function(callback) {\n      var nodes = this.allNodes();\n      var edges = this.allEdges();\n      this.createGraphObject(nodes, edges, function(graph_object) {\n        var json_graph_object = JSON.stringify(graph_object);\n        callback(json_graph_object);\n      });\n    },\n\n    // logString: function() {\n    //   GraphEditor.stringify(function(s) { console.log(s); });\n    // },\n    \n    load: function(json) {\n      \n      var graph_object = JSON.parse(json);\n      \n      var worker_attributes = graph_object.worker_attributes;\n      \n      var image_urls = [];\n      \n      for (var runtime in worker_attributes) {\n        for (var i = 0; i < worker_attributes[runtime].length; i++) {\n          var worker_attribute = worker_attributes[runtime][i];\n          if (runtime == "Animation") {\n            if (worker_attribute.inputAttributes && worker_attribute.inputAttributes.url) {\n              image_urls.push(worker_attribute.inputAttributes.url);\n            }\n          }\n        }\n      }\n      \n      this.imagesLoaded = 0;\n      this.imageUrlsOnLoad = image_urls.length;\n      \n      this.initGraphObject(graph_object);\n      this.resize();\n      \n      if (graph_object.nodes.length === 0) {\n        GraphEditor.emit("projectLoaded");\n      }\n      \n      if (this.imageUrlsOnLoad === 0) {\n        GraphEditor.emit("projectLoaded");\n      }\n      \n    },\n    \n    /*\n    \n    RunTime Communication\n    \n    ===================== */\n\n    getWorkerAttributes: function(node, callback) {\n      var options = {\n        runtime: node.runtime,\n        worker_id: node.id\n      };\n      var json_options = JSON.stringify(options);\n      GraphEditor.emit("getWorkerAttributes", json_options);\n      GraphEditor.once("gotWorkerAttributes", function(json_return_object) {\n        var return_object = JSON.parse(json_return_object);\n        if (return_object === null) {\n          callback();\n          return;\n        }\n        if (return_object.worker_id == options.worker_id) {\n          callback(return_object.value);\n        }\n      });\n    },\n    \n    getAllWorkersAttributes: function(callback) {\n      GraphEditor.emit("getAllWorkersAttributes");\n      GraphEditor.once("gotAllWorkersAttributes", function(json_worker_attributes) {\n        var worker_attributes = JSON.parse(json_worker_attributes);\n        callback(worker_attributes);\n      });\n    },\n    \n    getWorkerAttributeFromInput: function(input, callback) {\n      var options = {\n        runtime: input.node.runtime,\n        worker_id: input.node.id,\n        input_name: input.name\n      };\n      var json_options = JSON.stringify(options);\n      GraphEditor.emit("getWorkerAttribute", json_options);\n      GraphEditor.once("gotWorkerAttribute", function(json_return_object) {\n        var return_object = JSON.parse(json_return_object);\n        if (return_object.worker_id == options.worker_id) {\n          callback(return_object.value);\n        }\n      });\n    },\n    \n    getRunTimeColor: function(runtime_name) {\n      return this.runtimeList[runtime_name].color;\n    },\n    \n    /*\n    \n    Layers\n    \n    ====== */\n    \n    updateLayeredNodeCount: function() {\n      \n      var current_node_list = this.currentPatch.nodeList;\n      var layered_node_list = [];\n      \n      var count = 0;\n      \n      var i, node;\n      for (i = 0; i < current_node_list.length; i++) {\n        node = current_node_list[i];\n        if (node.layered) {\n          count++;\n          layered_node_list.push(node);\n        }\n      }\n      \n      for (i = 0; i < layered_node_list.length; i++) {\n        node = layered_node_list[i];\n        node.updateLayerCount(count);\n        node.updateLayer(i);\n      }\n      \n    },\n    \n    reorderNodes: function(node_ids) {\n      \n      var current_node_list = this.currentPatch.nodeList;\n      \n      var new_node_list = [];\n      var other_nodes = [];\n      \n      var i;\n      for (i = 0; i < current_node_list.length; i++) {\n        var node = current_node_list[i];\n        var new_node_index = node_ids.indexOf(node.id);\n        \n        if (node.layered) {\n          node.updateLayer(new_node_index);\n        }\n        \n        if (new_node_index != -1) {\n          new_node_list[new_node_index] = node;\n        }\n        else {\n          other_nodes.push(node);\n        }\n      }\n      \n      for (i = 0; i < other_nodes.length; i++) {\n        new_node_list.push(other_nodes[i]);\n      }\n      \n      this.currentPatch.nodeList = new_node_list;\n      \n      GraphEditor.emit("reorderedNodes");\n      \n      \n    },\n    \n    /*\n    \n    Node and Plugin Registration\n    \n    ============================ */\n\n    registerNode: function(node, type, alias) {\n      extend(node, GraphEditor.Node);\n      this.nodeTypes[type] = node;\n      if (alias) {\n        this.nodeTypeAliases[alias] = type;\n      }\n    },\n\n    registerPlugin: function(name, plugin) {\n      this.pluginTypes[name] = plugin;\n    }\n\n  };\n  \n  $.extend(GraphEditor, Emitter);\n  \n  return GraphEditor;\n  \n});\n//@ sourceURL=/graph_editor/graph_editor.js'),eval('/*global define:false */\n/*global window:false */\n/*global setInterval:false */\ndefine(\'runtimes/runtime_manager\',[\'graph_editor/graph_editor\'], function(GraphEditor) {\n\n  var RuntimeManager = {\n  \n    runtimes_list: {}, // make this an array\n    runtimes_worker_list: {}, // make this an array\n    \n    runtimeEvents: [],\n  \n    init: function(options) {\n    \n      this.loadRuntimes(options.list);\n      \n      var fullscreen;\n      var params = window.location.href.split("?")[1];\n      if (params) {\n        var params_array = params.split("&");\n        if (params_array.indexOf("fullscreen=true") != -1) {\n          fullscreen = true;\n        }\n      }\n      \n      if (!fullscreen) {\n        this.initRuntimeEventsThrottle();\n      }\n    \n      var that = this;\n\n      // Listen for events from the graph editor\n      GraphEditor.on("connect", function(json_edge) {\n        var edge = JSON.parse(json_edge);      \n        that.connect(edge);\n      });\n\n      GraphEditor.on("disconnect", function(json_edge) {\n        var edge = JSON.parse(json_edge);      \n        that.disconnect(edge);\n      });\n\n      GraphEditor.on("create", function(json_node) {\n        var node = JSON.parse(json_node);\n        that.create(node);\n      });\n\n      GraphEditor.on("remove", function(json_node) {\n        var node = JSON.parse(json_node);\n        that.remove(node);\n      });\n    \n      GraphEditor.on("clearAll", function() {\n        var runtime_list = that.all();\n        for (var r in runtime_list) {\n          var runtime = runtime_list[r];\n          if (runtime.clearAll) {\n            runtime.clearAll();\n          }\n        }\n      });\n\n      GraphEditor.on("triggerGraphEditorEvent", function(json_event) {\n        var event = JSON.parse(json_event);\n        var registeredNode = that.findByName(\'Event\').registeredNodeInstances[event.node_id];\n        var runtime = registeredNode.runtime;\n        var worker = that.findByName(runtime).workers[event.node_id] || that.findByName(runtime).findWorkerById(event.node_id);\n        worker.events[event.name](event.event);\n      });\n    \n      GraphEditor.on("setAllWorkerAttributes", function(json_worker_attributes) {\n        var worker_attributes = JSON.parse(json_worker_attributes);\n        var runtime_list = that.all();\n        for (var r in worker_attributes) {\n          var runtime = runtime_list[r];\n          runtime.parse(worker_attributes[r]);\n        }\n      });\n    \n      GraphEditor.on("setWorkerAttributes", function(json_options) {\n        var options = JSON.parse(json_options);\n        var worker_attributes = options.worker_attributes;\n        var runtime = that.findByName(options.runtime);\n        runtime.parse([worker_attributes]);\n      });\n    \n      GraphEditor.on("getAllWorkersAttributes", function() {\n        var all_workers_attributes = {};\n        var runtime_list = that.all();\n        for (var r in runtime_list) {\n          var runtime = runtime_list[r];\n          if (runtime.allWorkersAttributes) {\n            all_workers_attributes[r] = runtime.allWorkersAttributes();\n          }\n        }\n        GraphEditor.emit("gotAllWorkersAttributes", JSON.stringify(all_workers_attributes));\n      });\n      \n      GraphEditor.on("getSnapshot", function() {\n        \n        var snapshot = that.runtimes_list.Animation.snapshot();\n        GraphEditor.emit("gotSnapshot", snapshot);\n        \n      });\n    \n      GraphEditor.on("getWorkerAttributes", function(json_options) {\n      \n        var options = JSON.parse(json_options);\n        var runtime = that.findByName(options.runtime);\n        \n        if (runtime.getWorkerAttributes) {\n          var worker_attributes = runtime.getWorkerAttributes(options);\n          GraphEditor.emit("gotWorkerAttributes", JSON.stringify(worker_attributes));\n        }\n        else {\n          GraphEditor.emit("gotWorkerAttributes", JSON.stringify(null));\n        }\n        \n      });\n    \n      GraphEditor.on("getWorkerAttribute", function(json_options) {\n        var options = JSON.parse(json_options);\n        var worker_attribute = options;\n        worker_attribute.value = that.findByName(options.runtime).getWorkerAttribute(options);\n        GraphEditor.emit("gotWorkerAttribute", JSON.stringify(worker_attribute));\n      });\n    \n      GraphEditor.on("setWorkerAttribute", function(json_options) {\n        var options = JSON.parse(json_options);\n        that.findByName(options.runtime).setWorkerAttribute(options);\n      });\n    \n      GraphEditor.on("setArrayBufferWorkerAttribute", function(options) {\n         // notice that this isn\'t JSON...\n        // we are gonna move over to window.postMessage at some point!\n        // http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast\n        // http://updates.html5rocks.com/2011/09/Workers-ArrayBuffer\n        that.findByName(options.runtime).setWorkerAttribute(options);\n      });\n      \n      GraphEditor.on("runtimeMessage", function(json_message) {\n        var message = JSON.parse(json_message);\n        var runtime = that.findByName(message.runtime);\n        if (runtime.incomingMessage) {\n          var workers = runtime.incomingMessage(message.name, message.body);\n          var node_ids = [];\n          for (var i = 0; i < workers.length; i++) {\n            var node_id = workers[i].id;\n            node_ids.push(node_id);\n          }\n          GraphEditor.emit("reorderNodes", node_ids);\n        }\n      });\n    \n      GraphEditor.emit("runTimesDidLoad");\n      \n      GraphEditor.on("projectLoaded", function() {\n        var runtime_list = that.all();\n        for (var r in runtime_list) {\n          var runtime = runtime_list[r];\n          if (runtime.onProjectLoad) {\n            runtime.onProjectLoad();\n          }\n        }\n      });\n \n    },\n  \n    loadRuntimes: function(list) {\n      for (var r in list) {\n        var runtime_options = list[r];\n        var runtime_name = runtime_options.name;\n        var runtime = this.findByName(runtime_name);\n        if (runtime.init) {\n          runtime_options.manager = this;\n          runtime.init(runtime_options);\n          var event = {\n            name: runtime_name,\n            color: runtime.color,\n            icon_src: runtime.icon_src,\n            display: runtime.display\n          };\n\n          GraphEditor.emit("registerRunTime", JSON.stringify(event));\n        }\n      }\n    },\n  \n    create: function(node) {\n      if (node.runtime) {\n        this.findByName(node.runtime).create(node);\n      }\n      else {\n        this.findByName(\'Event\').create(node);\n      }\n      this.findByName(\'Event\').registerInstance(node);\n    },\n  \n    remove: function(node) {\n      if (node.runtime) {\n        this.findByName(node.runtime).remove(node);\n      }\n      else {\n        this.findByName(\'Event\').remove(node);\n      }\n      this.findByName(\'Event\').unregisterInstance(node);\n    },\n  \n    connect: function(edge) {\n      var output_runtime = this.findByName(edge.output_runtime_name);\n      output_runtime.connect(edge);  \n    },\n  \n    disconnect: function(edge) {\n      var output_runtime = this.findByName(edge.output_runtime_name);\n      output_runtime.disconnect(edge);\n    },\n    \n    initRuntimeEventsThrottle: function() {\n      var that = this;\n      setInterval(function() {\n        var events = that.runtimeEvents;\n        if (events) {\n          that.runtimeEvents = [];\n          GraphEditor.emit("triggerRunTimeEvents", events);\n        }\n      }, 15);\n    },\n  \n    triggerEvent: function(event) {\n      if (event.force) {\n        GraphEditor.emit("triggerRunTimeEvents", [event]);\n      }\n      else {\n        this.runtimeEvents.push(event);\n      }\n    },\n  \n    findWorkerByName: function(name) {\n      return this.runtimes_worker_list[name];\n    },\n  \n    findByName: function(name) {\n      return this.runtimes_list[name];\n    },\n  \n    all: function() {\n      return this.runtimes_list;\n    },\n  \n    registerRuntime: function(name, runtime, worker) {\n      this.runtimes_list[name] = runtime;\n      this.runtimes_worker_list[name] = worker;\n    }\n  \n  };\n\n  return RuntimeManager;\n\n});\n//@ sourceURL=/runtimes/runtime_manager.js'),eval("/*global define:false */\ndefine('graph_editor/register_core',['graph_editor/graph_editor'], function(GraphEditor) {\n  \n  var registerCore = function (options) {\n\n    var name = options.name;\n    var core = options.core;\n\n    GraphEditor[name] = core;\n\n    if (core.prototype) {\n      core.prototype.editor = GraphEditor;\n    }\n    else {\n      core.editor = GraphEditor;\n    }\n\n  };\n  \n  return registerCore;\n  \n});\n\n\n//@ sourceURL=/graph_editor/register_core.js"),eval("/*global define:false */\ndefine('graph_editor/register_plugin',['graph_editor/graph_editor'], function(GraphEditor) {\n\n  var registerPlugin = function (options) {\n    GraphEditor.registerPlugin(options.name, options.plugin);\n  };\n  \n  return registerPlugin;\n  \n});\n//@ sourceURL=/graph_editor/register_plugin.js"),eval("define('runtimes/register_runtime',['runtimes/runtime_manager'], function(RuntimeManager) {\n\n  var registerRuntime = function (options) {\n  \n    var name = options.name;\n    var runtime = options.runtime;\n  \n    runtime.eventRuntime = RuntimeManager.findByName('Event');\n    runtime.eventWorker = RuntimeManager.findWorkerByName('Event');\n  \n    var worker = options.worker;\n  \n    worker.prototype.superParent = function(options) {\n      RuntimeManager.findWorkerByName('Event').call(this, options);\n    };\n  \n    RuntimeManager.registerRuntime(name, runtime, worker);\n\n  };\n\n  return registerRuntime;\n\n});\n//@ sourceURL=/runtimes/register_runtime.js"),eval("/*global define:false */\n/*global $:false */\ndefine('graph_editor/core/view_node',['graph_editor/register_core'], function(registerCore) {\n  \n  var ViewNode = function(options) {\n    this._initView(options);\n  };\n  ViewNode.prototype = {\n\n    _initView: function(options) {\n\n      this.node = options.node;\n      this.id = options.node.id;\n\n      this.events = {};\n\n      this.editor.View.nodes[this.id] = this;\n\n    },\n    \n    createCanvasAndAppendView: function(width, height) {\n      this.createCanvas(width, height);\n      this.appendView(this.$canvas[0]);\n    },\n    \n    createCanvas: function(width, height) {\n      \n      if (!width) {\n        width = this.node.$display.width();\n      }\n      if (!height) {\n        height = this.node.$display.height();\n      }\n      \n      this.$canvas = $(\"<canvas />\");\n      this.$canvas.css({\n        width: width,\n        height: height\n      });\n      \n      this.$canvas[0].width = width;\n      this.$canvas[0].height = height;\n      \n      this.context = this.$canvas[0].getContext('2d');\n      \n      this.context.width = width;\n      this.context.height = height;\n      \n      \n    },\n    \n    appendView: function(dom_element) {\n      var $dom_element = $(dom_element);\n      \n      var $view_display = this.node.$view_display;\n      \n      $view_display.append($dom_element);\n      \n    },\n\n    addEventListener: function(event_name, callback) {\n      this.events[event_name] = function(event) {\n        callback(event);\n      };\n    },\n\n    triggerEvent: function(event) {\n      event.node_id = this.id;\n      this.editor.View.triggerEvent(event);\n    }\n\n  };\n\n  registerCore({\n    name: \"ViewNode\",\n    core: ViewNode\n  });\n  \n});\n//@ sourceURL=/graph_editor/core/view_node.js"),eval("/*global define:false */\ndefine('graph_editor/core/view',['graph_editor/register_core','lib/extend', 'graph_editor/core/view_node'], function(registerCore, extend) {\n\n  var View = {\n\n    nodeTypes: {}, // make this an array\n    nodes: {}, // make this an array\n\n    registerNode: function(node, type) {\n      extend(node, this.editor.ViewNode);\n      this.nodeTypes[type] = node;\n    },\n\n    triggerEvent: function(event) {\n      var view_node = this.nodes[event.node_id];\n      if (view_node.events[event.name]) {\n        view_node.events[event.name](event.event);\n      }\n\n    }\n\n  };\n\n  registerCore({\n    name: \"View\",\n    core: View\n  });\n\n});\n//@ sourceURL=/graph_editor/core/view.js"),eval('/*global define:false */\n/*global $:false */\n/*global document:false */\ndefine(\'lib/draggable\',[],function() {\n  \n  var Draggable = {\n    \n    init: function($div, callback_moving, callback_endmove) {\n      \n      $div.on("mousedown touchstart", function(event) {\n        \n        $(document).on("selectstart", function() { return false; });\n        \n        var startX = event.pageX || event.originalEvent.pageX || event.originalEvent.touches[0].pageX;\n        var startY = event.pageY || event.originalEvent.pageY || event.originalEvent.touches[0].pageY;\n        var currentX = parseInt($div.css("left"), 10);\n        var currentY = parseInt($div.css("top"), 10);\n        $div.attr("dragging", true);\n        \n        var dX = 0;\n        var dY = 0;\n        \n        $(document.body).on("mousemove touchmove", function(event) {\n          \n          event.preventDefault();\n          \n          if ($div.attr("dragging")) {\n            \n            var moveX = event.pageX || event.originalEvent.pageX || event.originalEvent.touches[0].pageX;\n            var moveY = event.pageY || event.originalEvent.pageY || event.originalEvent.touches[0].pageY;\n            \n            dX = moveX - startX;\n            dY = moveY - startY;\n            \n            var newX = currentX + dX;\n            var newY = currentY + dY;\n            \n            $div.css({\n              left: newX,\n              top: newY\n            });\n            \n            if (callback_moving) {\n              callback_moving(dX, dY, moveX, moveY);\n            }\n            \n          }\n        });\n        \n        $(document.body).on("mouseup touchend", function() {\n          $(document).off("selectstart");\n          $div.attr("dragging", false);\n          $(document.body).off("mouseup touchend");\n          $(document.body).off("mousemove touchmove");\n          \n          if (callback_endmove) {\n            callback_endmove(dX, dY);\n          }\n          \n        });\n        \n      });\n      \n      \n      \n    }\n    \n  };\n  \n  return Draggable;\n  \n});\n//@ sourceURL=/lib/draggable.js'),eval('/*global define:false */\n/*global $:false */\n/*global document:false */\n/*global setTimeout:false */\n/*global clearTimeout:false */\ndefine(\'graph_editor/core/node\',[\'graph_editor/register_core\', \'lib/draggable\'], function(registerCore, Draggable) {\n\n  var Node = function(options) {\n    this._initNode(options);\n  };\n\n  Node.prototype = {\n\n    _initNode: function(options) {\n\n      if (!options.fill) {\n        options.fill = "#FFF";\n      }\n\n      this.options = options;\n\n      this.type = options.type;\n      this.titleText = options.titleText || this.type;\n\n      if (options.showIOLabelsWhenSelected === false) {\n        this.showIOLabelsWhenSelected = options.showIOLabelsWhenSelected;\n      }\n      else {\n        this.showIOLabelsWhenSelected = true;\n      }\n\n      this.x = options.x;\n      this.y = options.y;\n      this.fill = options.fill;\n      this.id = options.id;\n      \n      this.fadeIn = options.fade_in;\n\n      this.width = options.width || 143;\n\n      this.patch = this.editor.patchList[options.patch];\n\n      this.inputs = {}; // make this an array\n      this.outputs = {}; // make this an array\n\n      this.events = {}; // make this an array\n\n      this.edges = [];\n      \n      this.dragEvents = [];\n\n      this.drawNode();\n\n      this.setupEventHandlers();\n      \n      this.setupDragging();\n      \n      this.drawOutline();\n      \n      this.timestamp = (new Date()).toString();\n\n      this.patch.nodeList.push(this);\n\n      var node = {\n        id: this.id,\n        type: this.type,\n        runtime: this.runtime\n      };\n\n      this.editor.emit("create", JSON.stringify(node));\n\n    },\n\n    drawNode: function() {\n      \n      this.drawBox();\n      this.drawDisplay();\n      \n      this.drawIO();\n      \n      if (this.layered) {\n        this.drawLayerInterface();\n      }\n    },\n    \n    drawBox: function() {\n      this.$box = $(\'<div class="node"/>\');\n      \n      if (this.fadeIn) {\n        this.$box.hide();\n        this.$box.appendTo(this.patch.$nodeLayer);\n        this.$box.fadeIn();\n      }\n      else {\n        this.$box.appendTo(this.patch.$nodeLayer);\n      }\n      \n      this.$box.css({\n        left: this.x,\n        top: this.y,\n        width: this.width\n      });\n      \n    },\n    \n    drawDisplay: function() {\n      this.$display = $(\'<div class="display" />\');\n      this.$display.appendTo(this.$box);\n      \n      this.$view_display = $(\'<div class="view-display" />\');\n      this.$view_display.appendTo(this.$display);\n      \n      this.drawTitle();\n    },\n    \n    drawTitle: function() {\n      this.$title = $("<h3 />");\n      this.$title.text(this.titleText);\n      this.$title.appendTo(this.$display);\n    },\n    \n    drawIO: function() {\n      \n      this.$inputs = $(\'<ol class="inputs" />\');\n      this.$inputs.appendTo(this.$box);\n      \n      this.$outputs = $(\'<ol class="outputs" />\');\n      this.$outputs.appendTo(this.$box);\n      \n    },\n    \n    drawLayerInterface: function() {\n      \n      this.$layerSelect = $(\'<select />\');\n      this.$layerSelect.appendTo(this.$box);\n      this.$layerSelect.addClass(\'layer-select\');\n      \n      var that = this;\n      \n      this.$layerSelect.mousedown(function(event) {\n        event.stopPropagation();\n      });\n      \n      this.$layerSelect.change(function() {\n        that.changeLayer(that.$layerSelect.val());\n      });\n      \n    },\n    \n    drawOutline: function() {\n      this.$outline = $(\'<div class="outline"/>\');\n      \n      this.$outline.appendTo(this.$box);\n    },\n\n    setupEventHandlers: function() {\n      \n      var that = this;\n      \n      this.$box.on("mousedown", function(event) {\n        that.patch.selectNodeWithMouse(that, event, event.shiftKey);\n        event.stopPropagation();\n      });\n      \n      var oneSecPress;\n      this.$box.on("touchstart", function(event) {\n        that.patch.selectNodeWithTouch(that, event, event.shiftKey);\n        oneSecPress = setTimeout(function() {\n          var conf = confirm("Delete node?");\n          if (conf === true){\n            that.editor.removeNodes([that]);\n          }\n        }, 800);\n        event.stopPropagation();\n      });\n      \n      this.$box.on("touchmove", function() {\n        clearTimeout(oneSecPress);\n      });\n      \n      this.$box.on("touchend", function() {\n        clearTimeout(oneSecPress);\n      });\n      \n    },\n    \n    setupDragging: function() {\n      var patch = this.patch;\n      var node = this;\n      Draggable.init(this.$box, function(dX, dY) {\n        node.callDragEvents(dX, dY);\n        for (var i = 0; i < patch.selectedNodes.length; i++) {\n          var selected_node = patch.selectedNodes[i];\n          if (node != selected_node) {\n            selected_node.moveBy(dX, dY);\n          }\n        }\n        patch.redrawEdges();\n      }, function(dX, dY) {\n        if (dX == 0 && dY == 0) {\n          return;\n        }\n        node.editor.emit("nodeMoved", node);\n        for (var i = 0; i < patch.selectedNodes.length; i++) {\n          var selected_node = patch.selectedNodes[i];\n          if (node != selected_node) {\n            selected_node.moveEndedAt(dX, dY);\n          }\n        }\n      });\n    },\n    \n    callDragEvents: function(dX, dY) {\n      for (var i = 0; i < this.dragEvents.length; i++) {\n        var drag_event = this.dragEvents[i];\n        drag_event(dX, dY, this);\n      }\n    },\n    \n    addDragEventListener: function(callback) {\n      this.dragEvents.push(callback);\n    },\n    \n    moveEndedAt: function(dX, dY) {\n      this.x += dX;\n      this.y += dY;\n    },\n    \n    moveBy: function(dX, dY) {\n      this.$box.css({\n        left: this.x + dX,\n        top: this.y + dY\n      });\n    },\n\n    moveTo: function(x, y) {\n            \n      this.x = x;\n      this.y = y;\n      \n      this.$box.css({\n        left: this.x,\n        top: this.y\n      });\n      \n    },\n    \n    getX: function() {\n      return parseInt(this.$box.css("left"), 10);\n    },\n    \n    getY: function() {\n      return parseInt(this.$box.css("top"), 10);\n    },\n    \n    updateLayerCount: function(layer_count) {\n      this.$layerSelect.html("");\n      \n      for (var i = 0; i < layer_count; i++) {\n        var $option = $("<option />");\n        $option.text(layer_count-i);\n        $option.attr("value", i);\n        //$option.val(i);\n        this.$layerSelect.append($option);\n      }\n      \n    },\n    \n    updateLayer: function(layer) {\n      this.$layerSelect.find("option[value=" + layer + "]")[0].selected = true;\n    },\n    \n    changeLayer: function(layer) {\n      var message = {\n        runtime: "Animation", \n        name:"changeLayer", \n        body: {\n          worker_id: this.id, \n          layer: layer\n        }\n      }; \n      this.editor.emit("runtimeMessage", JSON.stringify(message));\n    },\n\n    enableIOLabels: function(io_labels_enabled) {\n      for (var i in this.inputs) {\n        var input = this.inputs[i];\n        input.enableLabel(io_labels_enabled);\n      }\n\n      for (var o in this.outputs) {\n        var output = this.outputs[o];\n        output.enableLabel(io_labels_enabled);\n      }\n    },\n\n    inputCount: function() {\n      return this.ioCount(this.inputs);\n    },\n\n    outputCount: function() {\n      return this.ioCount(this.outputs);\n    },\n\n    ioCount: function(io) {\n      var count = 0;\n      for (var i in io) {\n        count++;\n        i = null;\n      }\n      return count;\n    },\n    \n    recomputeOutline: function() {\n      \n      var width = this.$box.width() + 4;\n      var height = this.$box.height() +4;\n      \n      this.$outline.css({\n        width: width,\n        height: height\n      });\n    },\n    \n    recomputeIO: function() {\n      if (this.$inputs.height() < this.$outputs.height()) {\n        this.$inputs.css({\n          \'min-height\': this.$outputs.height()\n        });\n      }\n\n    },\n\n    createInput: function(options) {\n      options.node = this;\n      options.type = "input";\n      options.num = this.inputCount();\n      if (!options.runtime) {\n        options.runtime = "Event";\n      }\n      var input = new this.editor.IO(options);\n      input.$view.appendTo(this.$inputs);\n      \n      this.recomputeOutline();\n      \n      this.inputs[options.name] = input;  \n    \n      var that = this;\n\n      input.$view.on("mouseup", function(evt) {\n        evt.stopPropagation();\n        that.editor.emit("nodeInputMouseUp", input);\n      });\n      \n      input.$view.on("mousedown", function(evt) {\n        evt.stopPropagation();\n        that.editor.emit("nodeInputMouseDown", input);\n      });\n      \n      var showTextInputTimeout;\n      input.$view.on("mouseleave", function() {\n        clearTimeout(showTextInputTimeout);\n      });\n      \n      input.$view.on("mouseenter", function(evt) {\n        if (input.isConnected()) {\n          return;\n        }\n        if (that.editor.edgeIsDrawing) {\n          return;\n        }\n        if (that.editor.disableMouseoverInput) {\n          return;\n        }\n        if (input.name == "color") {\n          return;\n        }\n        evt.stopPropagation();\n      \n        showTextInputTimeout = setTimeout(function() {\n          input.showTextInput(true);\n        }, 230);\n        \n      });\n      \n      input.$view.on("click", function(evt) {\n        evt.stopPropagation();\n        that.editor.emit("nodeInputDblClick", input);\n        input.showTextInput();\n      });\n      \n      \n      // this is a mess, mainly because: \n      \n      // "The event\'s target is the same element that received the touchstart event corresponding to the touch point, \n      //  even if the touch point has moved outside that element."\n      \n      // This being said, abstracting out this stuff to a lib could be very useful!\n      // The lib would make touchstart/touchend work like mousedown/mouseup\n      \n      \n      \n      var disconnecting;\n      input.$view.on("touchstart", function(evt) {\n        evt.stopPropagation();\n        disconnecting = true;\n        that.editor.emit("nodeInputTouchStart", input);\n      });\n      \n      var pageX, pageY, screenX, screenY;\n      input.$view.on("touchmove", function(evt) {\n        \n        pageX = evt.pageX || evt.originalEvent.pageX || evt.originalEvent.touches[0].pageX;\n        //var endX = pageX;\n        pageY = evt.pageY || evt.originalEvent.pageY || evt.originalEvent.touches[0].pageY;\n        //var endY = pageY - that.editor.$stage.offset().top;\n        \n        if (evt.originalEvent.pageX === 0) { // temp hack for bug in Chrome for Android\n          screenX = evt.originalEvent.touches[0].screenX;\n          screenY = evt.originalEvent.touches[0].screenY;\n        }\n      });\n      \n      input.$view.on("touchend", function(evt) {\n        \n        evt.stopPropagation();\n        \n        var e;\n        if (screenX) { // temp hack for bug in Chrome for Android\n          e = document.elementFromPoint(screenX, screenY);\n        }\n        else {\n          e = document.elementFromPoint(pageX, pageY);\n        }\n        \n        var check_input;\n        var input_name = $(e).attr("input");\n        if (input_name) {\n          check_input = that.inputs[input_name];\n          that.editor.emit("nodeInputTouchEnd", check_input);\n        }\n        \n        that.patch.redrawEdges();\n        \n        if (!check_input && !disconnecting) {\n          that.editor.emit("nodeInputTouchEnd", input);\n        }\n        else {\n          disconnecting = false;\n        }\n        \n      });\n\n      return input;\n    },\n\n    createOutput: function(options) {\n      options.node = this;\n      options.type = "output";\n      options.num = this.outputCount();\n      if (!options.runtime) {\n        options.runtime = "Event";\n      }\n      var output = new this.editor.IO(options);\n      output.$view.appendTo(this.$outputs);\n      \n      this.outputs[options.name] = output;\n      \n      this.recomputeOutline();\n      this.recomputeIO();\n    \n      var that = this;\n\n      output.$view.on("mousedown", function(evt) {\n        evt.stopPropagation();\n        that.editor.emit("nodeOutputMouseDown", output);\n      });\n      \n      output.$view.on("touchstart", function(evt) {\n        evt.stopPropagation();\n        that.editor.emit("nodeOutputTouchStart", output);\n      });\n\n      return output;\n    },\n\n    resize: function(width, height) {\n      this.width = width;\n      this.height = height;\n      this.$box.css({\n        left: this.width,\n        top: this.height\n      });\n    },\n\n    canConnectToInput: function(destination, output_name, input_name) {\n      if (!destination) {\n        return false;\n      }\n      return (destination.inputs[input_name].runtime_name == this.outputs[output_name].runtime_name);\n    },\n\n    connect: function(destination, output_name, input_name) {\n\n      if (!this.canConnectToInput(destination, output_name, input_name)) {\n        return;\n      }\n\n      var input_edges = destination.findEdgesByInputName(input_name);\n\n      if (input_edges.length > 0) {\n        input_edges[0].remove();\n      }\n\n      var edge = new this.editor.Edge({\n        source: this,\n        output_name: output_name,\n        destination: destination,\n        input_name: input_name,\n        patch: destination.patch,\n        line_type: "solid"\n      });\n      \n      this.patch.edgeList.push(edge);\n\n      this.edges.push(edge);\n\n      destination.edges.push(edge);\n\n      var input = destination.inputs[input_name];\n\n      var source = edge.source;\n      var output = source.outputs[output_name];\n\n      var output_runtime_name = output.runtime_name;\n      var input_runtime_name = input.runtime_name;\n\n      var edge_output = {\n        source_id: edge.source.id,\n        destination_id: edge.destination.id,\n        output_name: edge.output_name,\n        input_name: edge.input_name,\n        output_runtime_name: output_runtime_name,\n        input_runtime_name: input_runtime_name\n      };\n\n      this.editor.emit("connect", JSON.stringify(edge_output));\n\n      return edge;\n\n    },\n\n    disconnect: function(edge) {\n\n      var destination = edge.destination;\n      var input_name = edge.input_name;\n      var input = destination.inputs[input_name];\n\n      var source = edge.source;\n      var output_name = edge.output_name;\n      var output = source.outputs[output_name];\n\n      var output_runtime_name = output.runtime_name;\n      var input_runtime_name = input.runtime_name;\n\n      var edge_output = {\n        source_id: edge.source.id,\n        destination_id: edge.destination.id,\n        output_name: edge.output_name,\n        input_name: edge.input_name,\n        output_runtime_name: output_runtime_name,\n        input_runtime_name: input_runtime_name\n      };\n\n      this.editor.emit("disconnect", JSON.stringify(edge_output));\n\n    },\n\n    remove: function() {\n\n      if (!this.removed) {\n        //console.log("removing node:", this.id);\n        this.removed = true;\n        this.disconnectAll();\n        if (this.onRemove) {\n          this.onRemove();\n        }\n\n        this.patch.removeNodes([this]);\n        \n      }\n\n      var node = {\n        id: this.id,\n        type: this.type,\n        runtime: this.runtime\n      };\n    \n      var that = this;\n\n      setTimeout(function() {\n        that.editor.emit("remove", JSON.stringify(node));\n      }, 13); // STINK!\n\n    },\n\n    disconnectAll: function() {\n      var edge = this.edges[0];\n      while (edge) {\n        edge.remove();\n        edge = this.edges[0];\n      }\n    },\n\n    findEdgesByOutputName: function(output_name) {\n      var edges = [];\n      for (var i = 0; i < this.edges.length; i++) {\n        var edge = this.edges[i];\n        if (edge.source == this && edge.output_name == output_name) {\n          edges.push(edge);\n        }\n      }\n      return edges;\n    },\n\n    findEdgesByInputName: function(input_name) {\n      var edges = [];\n      for (var i = 0; i < this.edges.length; i++) {\n        var edge = this.edges[i];\n        if (edge.destination == this && edge.input_name == input_name) {\n          edges.push(edge);\n        }\n      }\n      return edges;\n    },\n\n    isSelected: function() {\n      return (this.editor.currentPatch.selectedNodes.indexOf(this) != -1);\n    },\n\n    addEventListener: function(event_name, callback) {\n      this.events[event_name] = function(event) {\n        callback(event);\n      };\n    },\n\n    triggerEvent: function(event) {\n      event.node_id = this.id;\n      this.editor.emit("triggerGraphEditorEvent", JSON.stringify(event));\n    }\n\n  };\n\n  registerCore({\n    name: "Node",\n    core: Node\n  });\n  \n});\n//@ sourceURL=/graph_editor/core/node.js'),eval("/*global define:false */\ndefine('register_node',['graph_editor/graph_editor', 'runtimes/runtime_manager', 'graph_editor/core/view', 'graph_editor/core/view_node', 'graph_editor/core/node', 'register_node'], function(GraphEditor, RuntimeManager) {\n\n  var registerNode = function (options) {\n  \n    var name = options.name;\n    var runtime = options.runtime || \"Event\";\n  \n    var node = options.node; \n    if (node) {\n      var alias = options.alias; \n      node.prototype.runtime = runtime;\n      node.prototype.callSuper = function(options) {\n        GraphEditor.Node.call(this, options);\n      };\n      GraphEditor.registerNode(node, name, alias);\n    }\n    var view = options.view;\n    if (view) {\n      view.prototype.runtime = runtime;\n      view.prototype.callSuper = function(options) {\n        GraphEditor.ViewNode.call(this, options);\n      };\n      GraphEditor.View.registerNode(view, name);\n    }\n  \n    var worker = options.worker;\n    if (worker && RuntimeManager.findByName(runtime)) {\n      worker.prototype.runtime = runtime;\n      worker.prototype.callSuper = function(options) {\n        RuntimeManager.findWorkerByName(runtime).call(this, options);\n      };\n      worker.prototype.trigger = function(options) {\n        RuntimeManager.findByName('Event').trigger(options);\n      };\n      worker.prototype.parentRuntime = RuntimeManager.findByName(runtime);\n      RuntimeManager.findByName(runtime).registerWorker(worker, name);\n    }\n\n  };\n  \n  return registerNode;\n  \n});\n//@ sourceURL=/register_node.js"),eval("/*global define:false */\ndefine('graph_editor/core/command',['graph_editor/register_core'], function(registerCore) {\n  \n  var Command = function(options) {\n\n    this._initCommand(options);\n\n  };\n\n  Command.prototype = {\n\n    _initCommand: function(options) {\n      \n      this.name = options.name;\n\n      this.undoFunction = options.undo;\n      this.redoFunction = options.exec;\n\n      this.editor.commandHistoryList.push(this);\n      this.editor.commandFutureList = [];\n\n      this.editor.emit(\"newCommand\", this);\n\n      this.redoFunction();\n\n    },\n\n    undo: function() {\n      this.undoFunction();\n    },\n\n    redo: function() {\n      this.redoFunction();\n    }\n\n  };\n\n  registerCore({\n    name: \"Command\",\n    core: Command\n  });\n\n});\n\n\n//@ sourceURL=/graph_editor/core/command.js"),eval('/*global define:false */\n/*global $:false */\n/*global window:false */\n/*global document:false */\ndefine(\'graph_editor/core/comment\',[\'graph_editor/register_core\'], function(registerCore) {\n\n  var Comment = function(options) {\n    this._initComment(options);\n  };\n\n  Comment.prototype = {\n\n    _initComment: function(options) {\n\n      this.options = options;\n      this.x = options.x || 100;\n      this.y = options.y || 100;\n      this.width = 300;\n      this.height = 100;\n      this.fill = "rgba(0,0,0,0.1)";\n      this.text = options.text;\n\n      this.patch = this.editor.currentPatch;\n      this.patch.selectedComments = [];\n\n      this.drawComment();\n      this.setupEventHandlers();\n\n      this.editor.emit("updated");\n      this.editor.comments.push(this);\n\n    },\n\n    drawComment: function() {\n\n      // this.group = new Kinetic.Group({\n      //   x: this.x,\n      //   y: this.y,\n      //   draggable: true\n      // });\n      // \n      // this.box = new Kinetic.Rect({\n      //   x: 0,\n      //   y: 0,\n      //   width: this.width,\n      //   height: this.height,\n      //   fill: this.fill,\n      //   stroke: "rgba(255, 255, 255, 0.1)",\n      //   strokeWidth: 1,\n      //   cornerRadius: 1,\n      //   opacity: 1.0,\n      //   lineJoin: "round",\n      //   dashArray: [3, 1]\n      // });\n      // \n      // this.textRect = new Kinetic.Text({\n      //   x: 5,\n      //   y: 5,\n      //   text: this.text,\n      //   fontSize: 10,\n      //   fontFamily: "Arial",\n      //   textFill: "white"\n      // });\n\n      //this.group.add(this.textRect);\n      //this.group.add(this.box);\n\n      //this.patch.nodeLayer.add(this.group);\n      //this.group.moveToBottom();\n      //this.patch.nodeLayer.draw();\n\n    },\n\n    setupEventHandlers: function() {\n\n      var that = this;\n\n      // this.group.on("dragend", function(evt) {\n      //   that.x = that.group.getX();\n      //   that.y = that.group.getY();\n      //   that.editor.emit("updated");\n      // });\n\n      $(window).on("keyup", function(evt) {\n        evt.preventDefault();\n        if (that.editor.modalWindowOpen) {\n          return;\n        }\n        if (evt.keyCode == 8) {\n          for (var i = 0; i < that.editor.currentPatch.selectedComments.length; i++) {\n            var comment = that.editor.currentPatch.selectedComments[i];\n            comment.remove();\n          }\n          that.editor.currentPatch.selectedComments = [];\n        }\n        return false;\n      });\n\n      // this.editor.stage.on("mousedown", function(evt) {\n      //   that.editor.currentPatch.selectedComments = [];\n      // });\n\n      // this.group.on("mousedown", function(evt) {\n      //   that.editor.currentPatch.selectedComments.push(that);\n      //   evt.cancelBubble = true;\n      // });\n      // \n      // this.group.on("dblclick", function(evt) {\n      //   that.showTextArea();\n      // });\n\n    },\n\n    remove: function() {\n      this.editor.comments.splice(this.editor.comments.indexOf(this), 1);\n      this.patch.nodeLayer.remove(this.group);\n      //this.patch.nodeLayer.draw();\n      this.editor.emit("updated");\n    },\n\n    updateText: function(text) {\n      this.text = text;\n      this.options.text = text;\n      //this.textRect.setText(text);\n      //this.patch.nodeLayer.draw();\n      this.editor.emit("updated");\n    },\n\n    showTextArea: function() {\n\n      var that = this;\n\n      var screen = $("<div />");\n      screen.css({\n        position: "fixed",\n        top: 0,\n        left: 0,\n        width: 9000,\n        height: 9000,\n        background: "#000",\n        opacity: 0.15\n      });\n      screen.appendTo($(document.body));\n\n      this.editor.modalWindowOpen = true;\n\n      var text = this.text;\n\n      var top = this.y + 3;\n      var left = this.x + 3;\n      var width = this.width - 6;\n      var height = this.height - 6;\n\n      var form = $("<form />");\n      form.appendTo($(document.body));\n\n      var textInput = $("<textarea />");\n      textInput[0].value = text;  \n      textInput.css({\n        position: "absolute", \n        top: top, \n        left: left, \n        width: width,\n        height: height\n      });\n      textInput.appendTo(form);\n\n      screen.click(function() {\n        that.editor.modalWindowOpen = false;\n        that.updateText(textInput[0].value);\n        form.remove();\n        screen.remove();\n      });\n\n    }\n\n  };\n\n  registerCore({\n    name: "Comment",\n    core: Comment\n  });\n\n});\n\n//@ sourceURL=/graph_editor/core/comment.js'),eval('/*global define:false */\ndefine(\'graph_editor/core/edge\',[\'graph_editor/register_core\'], function(registerCore) {\n  \n  var Edge = function(options) {\n    this._initEdge(options);\n  };\n\n  Edge.prototype = {\n\n    _initEdge: function(options) {\n\n      this.source = options.source;\n      this.output_name = options.output_name;\n      this.output = this.source.outputs[this.output_name];\n      this.destination = options.destination;\n      this.input_name = options.input_name;\n      this.input = this.destination.inputs[this.input_name];\n      this.runtime_name = this.output.runtime_name;\n      \n      this.lineType = options.line_type;\n      this.lineColor = options.line_color || \'#30e8ca\';\n\n      this.bezierDeflection = 30;\n\n      this.patch = options.patch;\n      \n      this.drawLine();\n\n      this.setupSelectHandler();\n\n    },\n\n    setupSelectHandler: function() {\n      //var that = this;\n      // this.targetArea.on("mousedown touchstart", function(evt) {\n      //   that.patch.selectEdge(that, evt, evt.shiftKey);\n      // });\n    },\n\n    drawLine: function() {\n      \n      if (this.lineType == "solid") {\n        this.drawSolidLine();\n      }\n      if (this.lineType == "dashed") {\n        this.drawDashedLine();\n      }\n\n    },\n    \n    drawSolidLine: function() {\n      var startX = this.output.getX();\n      var startY = this.output.getY();\n\n      var endX = this.input.getX();\n      var endY = this.input.getY();\n      \n      var context = this.patch.edgeContext;\n      \n      context.strokeStyle = this.lineColor;\n      context.lineWidth = 3;\n      context.lineCap = "round";\n      context.beginPath();\n      context.moveTo(startX, startY);\n      context.bezierCurveTo(startX + 60, startY, endX - 60, endY, endX, endY);\n      context.stroke();\n      \n    },\n    \n    // http://davidowens.wordpress.com/2010/09/07/html-5-canvas-and-dashed-lines/\n    \n    drawDashedLine: function(pattern_option) {\n      \n      var pattern = pattern_option || [10,5];\n      \n      var startX = this.output.getX();\n      var startY = this.output.getY();\n\n      var endX = this.input.getX();\n      var endY = this.input.getY();\n      \n      var context = this.patch.edgeContext;\n      \n      var lt = function (a, b) { return a <= b; };\n      var gt = function (a, b) { return a >= b; };\n      var capmin = function (a, b) { return Math.min(a, b); };\n      var capmax = function (a, b) { return Math.max(a, b); };\n\n      var checkX = { thereYet: gt, cap: capmin };\n      var checkY = { thereYet: gt, cap: capmin };\n\n      if (startY - endY > 0) {\n        checkY.thereYet = lt;\n        checkY.cap = capmax;\n      }\n      if (startX - endX > 0) {\n        checkX.thereYet = lt;\n        checkX.cap = capmax;\n      }\n      \n      context.strokeStyle = this.lineColor;\n      context.lineWidth = 3;\n      context.lineCap = "round";\n      context.beginPath();\n\n      context.moveTo(startX, startY);\n      var offsetX = startX;\n      var offsetY = startY;\n      var idx = 0, dash = true;\n      while (!(checkX.thereYet(offsetX, endX) && checkY.thereYet(offsetY, endY))) {\n        var ang = Math.atan2(endY - startY, endX - startX);\n        var len = pattern[idx];\n\n        offsetX = checkX.cap(endX, offsetX + (Math.cos(ang) * len));\n        offsetY = checkY.cap(endY, offsetY + (Math.sin(ang) * len));\n\n        if (dash) context.lineTo(offsetX, offsetY);\n        else context.moveTo(offsetX, offsetY);\n\n        idx = (idx + 1) % pattern.length;\n        dash = !dash;\n      }\n      \n      context.stroke();\n    },\n\n    remove: function() {\n\n      if (!this.removed) {\n        //console.log("removing edge", this.source.id, "<=>", this.destination.id);\n        this.removed = true;\n        this.destination.edges.splice(this.destination.edges.indexOf(this), 1);\n        this.source.edges.splice(this.source.edges.indexOf(this), 1);\n        this.source.disconnect(this);\n        this.patch.removeEdge(this);\n      }\n\n    }\n\n  };\n\n  registerCore({\n    name: "Edge",\n    core: Edge\n  });\n  \n});\n//@ sourceURL=/graph_editor/core/edge.js');var jscolor={dir:"/assets/jscolor/",bindClass:"color",binding:!0,preloading:!0,install:function(){jscolor.addEvent(window,"load",jscolor.init)},init:function(){jscolor.binding&&jscolor.bind(),jscolor.preloading&&jscolor.preload()},getDir:function(){if(!jscolor.dir){var e=jscolor.detectDir();jscolor.dir=e!==!1?e:"jscolor/"}return jscolor.dir},detectDir:function(){var e=location.href,t=document.getElementsByTagName("base");for(var n=0;n<t.length;n+=1)t[n].href&&(e=t[n].href);var t=document.getElementsByTagName("script");for(var n=0;n<t.length;n+=1)if(t[n].src&&/(^|\/)jscolor\.js([?#].*)?$/i.test(t[n].src)){var r=new jscolor.URI(t[n].src),i=r.toAbsolute(e);return i.path=i.path.replace(/[^\/]+$/,""),i.query=null,i.fragment=null,i.toString()}return!1},bind:function(){var e=new RegExp("(^|\\s)("+jscolor.bindClass+")\\s*(\\{[^}]*\\})?","i"),t=document.getElementsByTagName("input");for(var n=0;n<t.length;n+=1){var r;if(!t[n].color&&t[n].className&&(r=t[n].className.match(e))){var i={};if(r[3])try{i=(new Function("return ("+r[3]+")"))()}catch(s){}t[n].color=new jscolor.color(t[n],i)}}},preload:function(){for(var e in jscolor.imgRequire)jscolor.imgRequire.hasOwnProperty(e)&&jscolor.loadImage(e)},images:{pad:[181,101],sld:[16,101],cross:[15,15],arrow:[7,11]},imgRequire:{},imgLoaded:{},requireImage:function(e){jscolor.imgRequire[e]=!0},loadImage:function(e){jscolor.imgLoaded[e]||(jscolor.imgLoaded[e]=new Image,jscolor.imgLoaded[e].src=jscolor.getDir()+e)},fetchElement:function(e){return typeof e=="string"?document.getElementById(e):e},addEvent:function(e,t,n){e.addEventListener?e.addEventListener(t,n,!1):e.attachEvent&&e.attachEvent("on"+t,n)},fireEvent:function(e,t){if(!e)return;if(document.createEvent){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}else if(document.createEventObject){var n=document.createEventObject();e.fireEvent("on"+t,n)}else e["on"+t]&&e["on"+t]()},getElementPos:function(e){var t=e,n=e,r=0,i=0;if(t.offsetParent)do r+=t.offsetLeft,i+=t.offsetTop;while(t=t.offsetParent);while((n=n.parentNode)&&n.nodeName.toUpperCase()!=="BODY")r-=n.scrollLeft,i-=n.scrollTop;return[r,i]},getElementSize:function(e){return[e.offsetWidth,e.offsetHeight]},getRelMousePos:function(e){var t=0,n=0;return e||(e=window.event),typeof e.offsetX=="number"?(t=e.offsetX,n=e.offsetY):typeof e.layerX=="number"&&(t=e.layerX,n=e.layerY),{x:t,y:n}},getViewPos:function(){return typeof window.pageYOffset=="number"?[window.pageXOffset,window.pageYOffset]:document.body&&(document.body.scrollLeft||document.body.scrollTop)?[document.body.scrollLeft,document.body.scrollTop]:document.documentElement&&(document.documentElement.scrollLeft||document.documentElement.scrollTop)?[document.documentElement.scrollLeft,document.documentElement.scrollTop]:[0,0]},getViewSize:function(){return typeof window.innerWidth=="number"?[window.innerWidth,window.innerHeight]:document.body&&(document.body.clientWidth||document.body.clientHeight)?[document.body.clientWidth,document.body.clientHeight]:document.documentElement&&(document.documentElement.clientWidth||document.documentElement.clientHeight)?[document.documentElement.clientWidth,document.documentElement.clientHeight]:[0,0]},URI:function(e){function t(e){var t="";while(e)if(e.substr(0,3)==="../"||e.substr(0,2)==="./")e=e.replace(/^\.+/,"").substr(1);else if(e.substr(0,3)==="/./"||e==="/.")e="/"+e.substr(3);else if(e.substr(0,4)==="/../"||e==="/..")e="/"+e.substr(4),t=t.replace(/\/?[^\/]*$/,"");else if(e==="."||e==="..")e="";else{var n=e.match(/^\/?[^\/]*/)[0];e=e.substr(n.length),t+=n}return t}this.scheme=null,this.authority=null,this.path="",this.query=null,this.fragment=null,this.parse=function(e){var t=e.match(/^(([A-Za-z][0-9A-Za-z+.-]*)(:))?((\/\/)([^\/?#]*))?([^?#]*)((\?)([^#]*))?((#)(.*))?/);return this.scheme=t[3]?t[2]:null,this.authority=t[5]?t[6]:null,this.path=t[7],this.query=t[9]?t[10]:null,this.fragment=t[12]?t[13]:null,this},this.toString=function(){var e="";return this.scheme!==null&&(e=e+this.scheme+":"),this.authority!==null&&(e=e+"//"+this.authority),this.path!==null&&(e+=this.path),this.query!==null&&(e=e+"?"+this.query),this.fragment!==null&&(e=e+"#"+this.fragment),e},this.toAbsolute=function(e){var e=new jscolor.URI(e),n=this,r=new jscolor.URI;return e.scheme===null?!1:(n.scheme!==null&&n.scheme.toLowerCase()===e.scheme.toLowerCase()&&(n.scheme=null),n.scheme!==null?(r.scheme=n.scheme,r.authority=n.authority,r.path=t(n.path),r.query=n.query):(n.authority!==null?(r.authority=n.authority,r.path=t(n.path),r.query=n.query):(n.path===""?(r.path=e.path,n.query!==null?r.query=n.query:r.query=e.query):(n.path.substr(0,1)==="/"?r.path=t(n.path):(e.authority!==null&&e.path===""?r.path="/"+n.path:r.path=e.path.replace(/[^\/]+$/,"")+n.path,r.path=t(r.path)),r.query=n.query),r.authority=e.authority),r.scheme=e.scheme),r.fragment=n.fragment,r)},e&&this.parse(e)},color:function(e,t){function r(e,t,n){var r=Math.min(Math.min(e,t),n),i=Math.max(Math.max(e,t),n),s=i-r;if(s===0)return[null,0,i];var o=e===r?3+(n-t)/s:t===r?5+(e-n)/s:1+(t-e)/s;return[o===6?0:o,s/i,i]}function i(e,t,n){if(e===null)return[n,n,n];var r=Math.floor(e),i=r%2?e-r:1-(e-r),s=n*(1-t),o=n*(1-t*i);switch(r){case 6:case 0:return[n,o,s];case 1:return[o,n,s];case 2:return[s,n,o];case 3:return[s,o,n];case 4:return[o,s,n];case 5:return[n,s,o]}}function s(){delete jscolor.picker.owner,document.getElementsByTagName("body")[0].removeChild(jscolor.picker.boxB)}function o(t,n){function h(){var e=m.pickerInsetColor.split(/\s+/),t=e.length<2?e[0]:e[1]+" "+e[0]+" "+e[0]+" "+e[1];o.btn.style.borderColor=t}if(!jscolor.picker){jscolor.picker={box:document.createElement("div"),boxB:document.createElement("div"),pad:document.createElement("div"),padB:document.createElement("div"),padM:document.createElement("div"),sld:document.createElement("div"),sldB:document.createElement("div"),sldM:document.createElement("div"),btn:document.createElement("div"),btnS:document.createElement("span"),btnT:document.createTextNode(m.pickerCloseText)};for(var r=0,i=4;r<jscolor.images.sld[1];r+=i){var s=document.createElement("div");s.style.height=i+"px",s.style.fontSize="1px",s.style.lineHeight="0",jscolor.picker.sld.appendChild(s)}jscolor.picker.sldB.appendChild(jscolor.picker.sld),jscolor.picker.box.appendChild(jscolor.picker.sldB),jscolor.picker.box.appendChild(jscolor.picker.sldM),jscolor.picker.padB.appendChild(jscolor.picker.pad),jscolor.picker.box.appendChild(jscolor.picker.padB),jscolor.picker.box.appendChild(jscolor.picker.padM),jscolor.picker.btnS.appendChild(jscolor.picker.btnT),jscolor.picker.btn.appendChild(jscolor.picker.btnS),jscolor.picker.box.appendChild(jscolor.picker.btn),jscolor.picker.boxB.appendChild(jscolor.picker.box)}var o=jscolor.picker;o.box.onmouseup=o.box.onmouseout=function(){e.focus()},o.box.onmousedown=function(){y=!0},o.box.onmousemove=function(e){if(E||S)E&&p(e),S&&d(e),document.selection?document.selection.empty():window.getSelection&&window.getSelection().removeAllRanges(),v()},o.padM.onmouseup=o.padM.onmouseout=function(){E&&(E=!1,jscolor.fireEvent(b,"change"))},o.padM.onmousedown=function(e){switch(g){case 0:m.hsv[2]===0&&m.fromHSV(null,null,1);break;case 1:m.hsv[1]===0&&m.fromHSV(null,1,null)}E=!0,p(e),v()},o.sldM.onmouseup=o.sldM.onmouseout=function(){S&&(S=!1,jscolor.fireEvent(b,"change"))},o.sldM.onmousedown=function(e){S=!0,d(e),v()};var l=u(m);o.box.style.width=l[0]+"px",o.box.style.height=l[1]+"px",o.boxB.style.position="absolute",o.boxB.style.clear="both",o.boxB.style.left=t+"px",o.boxB.style.top=n+"px",o.boxB.style.zIndex=m.pickerZIndex,o.boxB.style.border=m.pickerBorder+"px solid",o.boxB.style.borderColor=m.pickerBorderColor,o.boxB.style.background=m.pickerFaceColor,o.pad.style.width=jscolor.images.pad[0]+"px",o.pad.style.height=jscolor.images.pad[1]+"px",o.padB.style.position="absolute",o.padB.style.left=m.pickerFace+"px",o.padB.style.top=m.pickerFace+"px",o.padB.style.border=m.pickerInset+"px solid",o.padB.style.borderColor=m.pickerInsetColor,o.padM.style.position="absolute",o.padM.style.left="0",o.padM.style.top="0",o.padM.style.width=m.pickerFace+2*m.pickerInset+jscolor.images.pad[0]+jscolor.images.arrow[0]+"px",o.padM.style.height=o.box.style.height,o.padM.style.cursor="crosshair",o.sld.style.overflow="hidden",o.sld.style.width=jscolor.images.sld[0]+"px",o.sld.style.height=jscolor.images.sld[1]+"px",o.sldB.style.display=m.slider?"block":"none",o.sldB.style.position="absolute",o.sldB.style.right=m.pickerFace+"px",o.sldB.style.top=m.pickerFace+"px",o.sldB.style.border=m.pickerInset+"px solid",o.sldB.style.borderColor=m.pickerInsetColor,o.sldM.style.display=m.slider?"block":"none",o.sldM.style.position="absolute",o.sldM.style.right="0",o.sldM.style.top="0",o.sldM.style.width=jscolor.images.sld[0]+jscolor.images.arrow[0]+m.pickerFace+2*m.pickerInset+"px",o.sldM.style.height=o.box.style.height;try{o.sldM.style.cursor="pointer"}catch(c){o.sldM.style.cursor="hand"}o.btn.style.display=m.pickerClosable?"block":"none",o.btn.style.position="absolute",o.btn.style.left=m.pickerFace+"px",o.btn.style.bottom=m.pickerFace+"px",o.btn.style.padding="0 15px",o.btn.style.height="18px",o.btn.style.border=m.pickerInset+"px solid",h(),o.btn.style.color=m.pickerButtonColor,o.btn.style.font="12px sans-serif",o.btn.style.textAlign="center";try{o.btn.style.cursor="pointer"}catch(c){o.btn.style.cursor="hand"}o.btn.onmousedown=function(){m.hidePicker()},o.btnS.style.lineHeight=o.btn.style.height;switch(g){case 0:var w="hs.png";break;case 1:var w="hv.png"}o.padM.style.backgroundImage="url('"+jscolor.getDir()+"cross.gif')",o.padM.style.backgroundRepeat="no-repeat",o.sldM.style.backgroundImage="url('"+jscolor.getDir()+"arrow.gif')",o.sldM.style.backgroundRepeat="no-repeat",o.pad.style.backgroundImage="url('"+jscolor.getDir()+w+"')",o.pad.style.backgroundRepeat="no-repeat",o.pad.style.backgroundPosition="0 0",a(),f(),jscolor.picker.owner=m,document.getElementsByTagName("body")[0].appendChild(o.boxB)}function u(e){var t=[2*e.pickerInset+2*e.pickerFace+jscolor.images.pad[0]+(e.slider?2*e.pickerInset+2*jscolor.images.arrow[0]+jscolor.images.sld[0]:0),e.pickerClosable?4*e.pickerInset+3*e.pickerFace+jscolor.images.pad[1]+e.pickerButtonHeight:2*e.pickerInset+2*e.pickerFace+jscolor.images.pad[1]];return t}function a(){switch(g){case 0:var e=1;break;case 1:var e=2}var t=Math.round(m.hsv[0]/6*(jscolor.images.pad[0]-1)),n=Math.round((1-m.hsv[e])*(jscolor.images.pad[1]-1));jscolor.picker.padM.style.backgroundPosition=m.pickerFace+m.pickerInset+t-Math.floor(jscolor.images.cross[0]/2)+"px "+(m.pickerFace+m.pickerInset+n-Math.floor(jscolor.images.cross[1]/2))+"px";var r=jscolor.picker.sld.childNodes;switch(g){case 0:var s=i(m.hsv[0],m.hsv[1],1);for(var o=0;o<r.length;o+=1)r[o].style.backgroundColor="rgb("+s[0]*(1-o/r.length)*100+"%,"+s[1]*(1-o/r.length)*100+"%,"+s[2]*(1-o/r.length)*100+"%)";break;case 1:var s,u,a=[m.hsv[2],0,0],o=Math.floor(m.hsv[0]),f=o%2?m.hsv[0]-o:1-(m.hsv[0]-o);switch(o){case 6:case 0:s=[0,1,2];break;case 1:s=[1,0,2];break;case 2:s=[2,0,1];break;case 3:s=[2,1,0];break;case 4:s=[1,2,0];break;case 5:s=[0,2,1]}for(var o=0;o<r.length;o+=1)u=1-1/(r.length-1)*o,a[1]=a[0]*(1-u*f),a[2]=a[0]*(1-u),r[o].style.backgroundColor="rgb("+a[s[0]]*100+"%,"+a[s[1]]*100+"%,"+a[s[2]]*100+"%)"}}function f(){switch(g){case 0:var e=2;break;case 1:var e=1}var t=Math.round((1-m.hsv[e])*(jscolor.images.sld[1]-1));jscolor.picker.sldM.style.backgroundPosition="0 "+(m.pickerFace+m.pickerInset+t-Math.floor(jscolor.images.arrow[1]/2))+"px"}function l(){return jscolor.picker&&jscolor.picker.owner===m}function c(){b===e&&m.importColor(),m.pickerOnfocus&&m.hidePicker()}function h(){b!==e&&m.importColor()}function p(e){var t=jscolor.getRelMousePos(e),n=t.x-m.pickerFace-m.pickerInset,r=t.y-m.pickerFace-m.pickerInset;switch(g){case 0:m.fromHSV(n*(6/(jscolor.images.pad[0]-1)),1-r/(jscolor.images.pad[1]-1),null,C);break;case 1:m.fromHSV(n*(6/(jscolor.images.pad[0]-1)),null,1-r/(jscolor.images.pad[1]-1),C)}}function d(e){var t=jscolor.getRelMousePos(e),n=t.y-m.pickerFace-m.pickerInset;switch(g){case 0:m.fromHSV(null,null,1-n/(jscolor.images.sld[1]-1),N);break;case 1:m.fromHSV(null,1-n/(jscolor.images.sld[1]-1),null,N)}}function v(){if(m.onImmediateChange){var e;typeof m.onImmediateChange=="string"?e=new Function(m.onImmediateChange):e=m.onImmediateChange,e.call(m)}}this.required=!0,this.adjust=!0,this.hash=!1,this.caps=!0,this.slider=!0,this.valueElement=e,this.styleElement=e,this.onImmediateChange=null,this.hsv=[0,0,1],this.rgb=[1,1,1],this.minH=0,this.maxH=6,this.minS=0,this.maxS=1,this.minV=0,this.maxV=1,this.pickerOnfocus=!0,this.pickerMode="HSV",this.pickerPosition="bottom",this.pickerSmartPosition=!0,this.pickerButtonHeight=20,this.pickerClosable=!1,this.pickerCloseText="Close",this.pickerButtonColor="ButtonText",this.pickerFace=10,this.pickerFaceColor="ThreeDFace",this.pickerBorder=1,this.pickerBorderColor="ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight",this.pickerInset=1,this.pickerInsetColor="ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow",this.pickerZIndex=1e4;for(var n in t)t.hasOwnProperty(n)&&(this[n]=t[n]);this.hidePicker=function(){l()&&s()},this.showPicker=function(){if(!l()){var t=jscolor.getElementPos(e),n=jscolor.getElementSize(e),r=jscolor.getViewPos(),i=jscolor.getViewSize(),s=u(this),a,f,c;switch(this.pickerPosition.toLowerCase()){case"left":a=1,f=0,c=-1;break;case"right":a=1,f=0,c=1;break;case"top":a=0,f=1,c=-1;break;default:a=0,f=1,c=1}var h=(n[f]+s[f])/2;if(!this.pickerSmartPosition)var p=[t[a],t[f]+n[f]-h+h*c];else var p=[-r[a]+t[a]+s[a]>i[a]?-r[a]+t[a]+n[a]/2>i[a]/2&&t[a]+n[a]-s[a]>=0?t[a]+n[a]-s[a]:t[a]:t[a],-r[f]+t[f]+n[f]+s[f]-h+h*c>i[f]?-r[f]+t[f]+n[f]/2>i[f]/2&&t[f]+n[f]-h-h*c>=0?t[f]+n[f]-h-h*c:t[f]+n[f]-h+h*c:t[f]+n[f]-h+h*c>=0?t[f]+n[f]-h+h*c:t[f]+n[f]-h-h*c];o(p[a],p[f])}},this.importColor=function(){b?this.adjust?!this.required&&/^\s*$/.test(b.value)?(b.value="",w.style.backgroundImage=w.jscStyle.backgroundImage,w.style.backgroundColor=w.jscStyle.backgroundColor,w.style.color=w.jscStyle.color,this.exportColor(x|T)):this.fromString(b.value)||this.exportColor():this.fromString(b.value,x)||(w.style.backgroundImage=w.jscStyle.backgroundImage,w.style.backgroundColor=w.jscStyle.backgroundColor,w.style.color=w.jscStyle.color,this.exportColor(x|T)):this.exportColor()},this.exportColor=function(e){if(!(e&x)&&b){var t=this.toString();this.caps&&(t=t.toUpperCase()),this.hash&&(t="#"+t),b.value=t}!(e&T)&&w&&(w.style.backgroundImage="none",w.style.backgroundColor="#"+this.toString(),w.style.color=.213*this.rgb[0]+.715*this.rgb[1]+.072*this.rgb[2]<.5?"#FFF":"#000"),!(e&N)&&l()&&a(),!(e&C)&&l()&&f()},this.fromHSV=function(e,t,n,r){e!==null&&(e=Math.max(0,this.minH,Math.min(6,this.maxH,e))),t!==null&&(t=Math.max(0,this.minS,Math.min(1,this.maxS,t))),n!==null&&(n=Math.max(0,this.minV,Math.min(1,this.maxV,n))),this.rgb=i(e===null?this.hsv[0]:this.hsv[0]=e,t===null?this.hsv[1]:this.hsv[1]=t,n===null?this.hsv[2]:this.hsv[2]=n),this.exportColor(r)},this.fromRGB=function(e,t,n,s){e!==null&&(e=Math.max(0,Math.min(1,e))),t!==null&&(t=Math.max(0,Math.min(1,t))),n!==null&&(n=Math.max(0,Math.min(1,n)));var o=r(e===null?this.rgb[0]:e,t===null?this.rgb[1]:t,n===null?this.rgb[2]:n);o[0]!==null&&(this.hsv[0]=Math.max(0,this.minH,Math.min(6,this.maxH,o[0]))),o[2]!==0&&(this.hsv[1]=o[1]===null?null:Math.max(0,this.minS,Math.min(1,this.maxS,o[1]))),this.hsv[2]=o[2]===null?null:Math.max(0,this.minV,Math.min(1,this.maxV,o[2]));var u=i(this.hsv[0],this.hsv[1],this.hsv[2]);this.rgb[0]=u[0],this.rgb[1]=u[1],this.rgb[2]=u[2],this.exportColor(s)},this.fromString=function(e,t){var n=e.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i);return n?(n[1].length===6?this.fromRGB(parseInt(n[1].substr(0,2),16)/255,parseInt(n[1].substr(2,2),16)/255,parseInt(n[1].substr(4,2),16)/255,t):this.fromRGB(parseInt(n[1].charAt(0)+n[1].charAt(0),16)/255,parseInt(n[1].charAt(1)+n[1].charAt(1),16)/255,parseInt(n[1].charAt(2)+n[1].charAt(2),16)/255,t),!0):!1},this.toString=function(){return(256|Math.round(255*this.rgb[0])).toString(16).substr(1)+(256|Math.round(255*this.rgb[1])).toString(16).substr(1)+(256|Math.round(255*this.rgb[2])).toString(16).substr(1)};var m=this,g=this.pickerMode.toLowerCase()==="hvs"?1:0,y=!1,b=jscolor.fetchElement(this.valueElement),w=jscolor.fetchElement(this.styleElement),E=!1,S=!1,x=1,T=2,N=4,C=8;jscolor.addEvent(e,"focus",function(){m.pickerOnfocus&&m.showPicker()}),jscolor.addEvent(e,"blur",function(){y?y=!1:window.setTimeout(function(){y||c(),y=!1},0)});if(b){var k=function(){m.fromString(b.value,x),v()};jscolor.addEvent(b,"keyup",k),jscolor.addEvent(b,"input",k),jscolor.addEvent(b,"blur",h),b.setAttribute("autocomplete","off")}w&&(w.jscStyle={backgroundImage:w.style.backgroundImage,backgroundColor:w.style.backgroundColor,color:w.style.color});switch(g){case 0:jscolor.requireImage("hs.png");break;case 1:jscolor.requireImage("hv.png")}jscolor.requireImage("cross.gif"),jscolor.requireImage("arrow.gif"),this.importColor()}};jscolor.install(),define("lib/jscolor/jscolor",function(){}),eval("/*global define:false */\n/*global $:false */\n/*global document:false */\n/*global jscolor:false */\ndefine('graph_editor/core/io',['graph_editor/register_core', 'lib/jscolor/jscolor'], function(registerCore) {\n\n  var IO = function(options) {\n    this._initIO(options);\n  };\n\n  IO.prototype = {\n\n    _initIO: function(options) {\n      this.node = options.node;\n      this.name = options.name;\n      this.type = options.type;\n      this.y_offset = options.y_offset || 25;\n      this.options = options;\n\n      this.runtime_name = options.runtime;\n      \n      this.select_options = options.select_options;\n      this.select_options_index = options.select_options_index;\n\n      this.num = options.num;\n\n      this.$view = $('<li />');\n      this.$view.addClass(this.runtime_name);\n\n      this.$label = $('<h4 />');\n      this.$label.text(this.name);\n      this.$label.attr(this.type, this.name);\n      this.$label.appendTo(this.$view);\n      \n      this.$nub = $('<div class=\"nub\"/>');\n      this.$nub.appendTo(this.$view);\n\n    },\n    \n    edge: function() {\n      if (this.type == \"input\") {\n        return this.node.findEdgesByInputName(this.name);\n      }\n      else {\n        return this.node.findEdgesByOutputName(this.name);\n      }\n      \n    },\n    \n    isConnected: function() {\n      return this.edge().length > 0;\n    },\n\n    getInputData: function(callback) {\n      this.editor.getWorkerAttributeFromInput(this, callback);\n    },\n\n    updateInputData: function(value, previous_value, preview) {\n      this.editor.setWorkerAttributeFromInput(this, value, previous_value, preview);\n    },\n\n    enableLabel: function(enable_label) {\n      if (enable_label) {\n        this.label.show();\n      }\n      else {\n        this.label.hide();\n      }\n    },\n\n    getX: function() {\n      var x_offset = this.$view.offset().left - this.node.editor.$stage.offset().left;\n      if (this.type == \"output\") {\n        x_offset += this.$view.width() + 10;\n      }\n      return x_offset;\n    },\n    \n    getY: function() {\n      return this.$view.offset().top - this.node.editor.$stage.offset().top + (this.$view.height() / 2) + 2;\n    },\n    \n    createFormInput: function(current_value) {\n      var $input;\n      var i, select_option, $option;\n      if (this.select_options_index) {\n        $input = $('<select />');\n        for (i = 0; i < this.select_options_index.length; i++) {\n          select_option = this.select_options_index[i];\n          $option = $('<option />');\n          $option.text(select_option);\n          $option.attr(\"value\", i);\n          $input.append($option);\n        }\n      }\n      else if (this.select_options) {\n        $input = $('<select />');\n        for (i = 0; i < this.select_options.length; i++) {\n          select_option = this.select_options[i];\n          $option = $('<option />');\n          $option.text(select_option);\n          $option.attr(\"value\", select_option);\n          $input.append($option);\n        }\n      }\n      else {\n        $input = $('<input type=\"text\" />');\n        this.createSliderFromInput($input, current_value);\n      }\n      return $input;\n    },\n    \n    hideTextInput: function() {\n      this.editor.modalWindowOpen = false;\n      this.$form.remove();\n    },\n    \n    createSliderFromInput: function($input, current_value) {\n      \n      var input = this;\n      \n      var startX, startY, dY, new_value;\n      \n      $input.css(\"cursor\", \"row-resize\");\n      \n      $input.mousedown(function(event) {\n        \n        $input.css({\n          '-webkit-touch-callout': 'none',\n          '-webkit-user-select': 'none',\n          '-khtml-user-select': 'none',\n          '-moz-user-select': 'none',\n          '-ms-user-select': 'none',\n          'user-select': 'none'\n        });\n        \n        startX = event.clientX;\n        startY = event.clientY;\n        \n        $(document).on(\"mousemove\", function(event) {\n          \n          $(document.body).css(\"cursor\", \"row-resize\");\n          \n          dY = startY - event.clientY;\n          \n          var rate;\n          if (event.shiftKey) {\n            rate = 1;\n          }\n          else {\n            rate = 0.01;\n          }\n          \n          new_value = (parseFloat(current_value, 10) + parseFloat(dY, 10) * rate).toPrecision(3);\n          \n          input.updateInputData(new_value, current_value, true);\n          $input.val(new_value);\n          \n        });\n        \n        var mouseup = function() {\n          \n          $(document.body).css(\"cursor\", \"default\");\n          \n          $(document).off(\"mousemove\");\n          $(document).off(\"mouseup\");\n          $input.off(\"mouseup\");\n          \n          $input.css({\n            '-webkit-touch-callout': 'all',\n            '-webkit-user-select': 'all',\n            '-khtml-user-select': 'all',\n            '-moz-user-select': 'all',\n            '-ms-user-select': 'all',\n            'user-select': 'all'\n          });\n          \n          input.updateInputData(new_value, current_value);\n          \n        };\n        \n        $input.on(\"mouseup\", function() {\n          mouseup();\n        });\n        \n        $(document).on(\"mouseup\", function() {\n          mouseup();\n        });\n        \n      });\n    },\n    \n    showTextInput: function() {\n      \n      var $input;\n      \n      if (this.$form && this.$form.is(\":visible\")) {\n        $input = this.$form.find(\"input\");\n        $input.focus();\n        $input.select();\n        return;\n      }\n      \n      $('.node-text-input').remove();\n      var input = this;\n      this.getInputData(function(current_value) {\n        if (current_value === undefined) {\n          current_value = \"\";\n        }\n        input.editor.modalWindowOpen = true;\n        input.$form = $('<form />');\n        \n        $input = input.createFormInput(current_value);\n        \n        input.$form.addClass(\"node-text-input\");\n        \n        if (input.name == \"color\") {\n          var color_picker = new jscolor.color($input[0], {pickerFaceColor:'transparent',pickerFace:3,pickerBorder:0,pickerInsetColor:'black'});\n          color_picker.fromString(current_value);\n        }\n        \n        if (parseInt(current_value, 10).toString() == current_value) {\n          current_value = parseInt(current_value, 10);\n        }\n        else if (parseFloat(current_value).toString() == current_value) {\n          current_value = parseFloat(current_value).toFixed(2);\n        }\n        \n        $input.val(current_value);\n        $input.appendTo(input.$form);\n        input.$form.appendTo(input.$view);\n        $input.focus();\n        $input.select();\n      \n        var $line = $(\"<div />\");\n        $line.addClass(\"line\");\n        $line.appendTo(input.$form);\n        \n        \n        \n        input.$form.change(function(event) {\n          event.preventDefault();\n          var new_value = $input.val();\n          input.updateInputData(new_value, current_value);\n          return false;\n        });\n        \n        input.$form.submit(function(event) {\n          event.preventDefault();\n          var new_value = $input.val();\n          input.updateInputData(new_value, current_value);\n          input.hideTextInput();\n          return false;\n        });\n        \n        input.editor.$stage.one(\"click\", function() {\n          input.hideTextInput();\n        });\n        \n        $input.click(function(event) {\n          event.stopPropagation();\n        });\n        \n      });\n        \n    }\n\n  };\n\n  registerCore({\n    name: \"IO\",\n    core: IO\n  });\n  \n});\n//@ sourceURL=/graph_editor/core/io.js"),eval("/*global define:false */\n/*global $:false */\n/*global document:false */\n/*global window:false */\ndefine('graph_editor/core/patch',['graph_editor/register_core'], function(registerCore) {\n\n  var Patch = function(options) {\n    this._initPatch(options);\n  };\n\n  Patch.prototype = {\n\n    _initPatch: function(options) {\n\n      this.nodeList = [];\n      this.edgeList = [];\n      \n      this.hintEdges = [];\n\n      this.selectedNodes = [];\n      this.selectedEdges = [];\n\n      this.children = [];\n\n      this.id = options.id;\n      if (options.parent) {\n        this.parent = options.parent;\n        this.parent.children.push(this);\n      }\n\n      this.setupLayers();\n\n      // register the patch with the graph editor\n      this.editor.patchList[this.id] = this;\n\n      this.setupEventHandlers();\n\n    },\n\n    setupLayers: function() {\n      \n      this.$edgeLayer = $('<canvas class=\"edge-layer\" />');\n      this.$edgeLayer.appendTo(this.editor.$stage);\n      this.edgeContext = this.$edgeLayer[0].getContext('2d');\n      \n      var width = $(document).width();\n      var height = $(document).height();\n      \n      this.$edgeLayer.css({\n        width: width,\n        height: height\n      });\n      this.$edgeLayer[0].width = width;\n      this.$edgeLayer[0].height = height;\n      this.edgeContext.width = width;\n      this.edgeContext.height = height;\n      \n      this.$nodeLayer = $('<div class=\"node-layer\" />');\n      this.$nodeLayer.appendTo(this.editor.$stage);      \n\n      this.$edgeLayer.hide();\n      this.$nodeLayer.hide();\n\n    },\n\n    setupEventHandlers: function() {\n      var that = this;\n\n      // taken from http://stackoverflow.com/questions/1495219/how-can-i-prevent-the-backspace-key-from-navigating-back\n      $(document).unbind('keydown').bind('keydown', function (event) {\n          var doPrevent = false;\n          if (event.keyCode === 8) {\n              var d = event.srcElement || event.target;\n              if ((d.tagName.toUpperCase() === 'INPUT' && (d.type.toUpperCase() === 'TEXT' || d.type.toUpperCase() === 'PASSWORD' || d.type.toUpperCase() === 'EMAIL')) || d.tagName.toUpperCase() === 'TEXTAREA') {\n                  doPrevent = d.readOnly || d.disabled;\n              }\n              else {\n                  doPrevent = true;\n              }\n          }\n\n          if (doPrevent) {\n              event.preventDefault();\n          }\n      });\n\n      $(window).on(\"keyup\", function(evt) {\n        evt.preventDefault();\n        if (that.editor.modalWindowOpen) {\n          return;\n        }\n        if (evt.keyCode == 8) {\n          that.editor.removeNodes(that.selectedNodes, that.selectedEdges);\n          that.selectedNodes = [];\n        }\n        return false;\n      });\n\n    },\n    \n    redrawEdges: function() {\n      var edges = this.edgeList;\n      var context = this.edgeContext;\n      context.clearRect (0, 0, context.width, context.height);\n      var i;\n      for (i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        edge.drawLine();\n      }\n      \n      var hint_edges = this.hintEdges || [];\n      for (i = 0; i < hint_edges.length; i++) {\n        var hint_edge = hint_edges[i];\n        hint_edge.drawLine();\n      }\n    },\n    \n    findEdgeByInput: function(input) {\n      for (var i = 0; i < this.edgeList.length; i++) {\n        var edge = this.edgeList[i];\n        if (input.node.id == edge.destination.id && input.name == edge.input_name) {\n          return edge;\n        }\n      }\n    },\n    \n    findNodeById: function(node_id) {\n      for (var i = 0; i < this.nodeList.length; i++) {\n        var node = this.nodeList[i];\n        if (node.id == node_id) {\n          return node;\n        }\n      }\n    },\n    \n    allNodes: function() {\n      return this.nodeList;\n    },\n    \n    allEdges: function() {\n      return this.edgeList;\n    },\n\n    selectNode: function(node, evt, add) {\n      //sn = node;\n\n      //console.log(\"selected node\", node.id  );\n\n      if (!add && this.selectedNodes.length < 2) {\n        this.editor.deselectAll();\n      }\n      \n      var i;\n      for (i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        this.selectEdge(edge, false, true);\n      }\n      \n      node.$box.addClass(\"selected\");\n\n      if (this.selectedNodes.indexOf(node) == -1) {\n        this.selectedNodes.push(node);\n      }\n\n      if (evt) {\n        evt.cancelBubble = true;\n      }\n      \n      for (i = 0; i < this.nodeList.length; i++) {\n        this.nodeList[i].$box.css(\"z-index\", 10);\n      }\n      \n      node.$box.css(\"z-index\", 20);\n\n    },\n\n    selectNodeWithMouse: function(node, evt, add) {\n\n      this.selectNode(node, evt, add);\n\n    },\n\n    selectNodeWithTouch: function(node, evt, add) {\n      \n      this.selectNode(node, evt, add);\n\n    },\n\n    deselectNode: function(node) {\n      node.$box.removeClass(\"selected\");\n      this.selectedNodes.splice(this.selectedNodes.indexOf(node), 1);\n    },\n\n    selectEdge: function(edge, evt, add) {\n\n      if (!add) {\n        this.editor.deselectAll();\n      }\n\n      this.selectedEdges.push(edge);\n\n      if (evt) {\n        evt.cancelBubble = true;\n      }\n\n    },\n\n    deselectAll: function() {\n      var i;\n      for (i = 0; i < this.nodeList.length; i++) {\n        var node = this.nodeList[i];\n        this.deselectNode(node);\n        this.selectedNodes = [];\n      }\n      for (i = 0; i < this.edgeList.length; i++) {\n        this.selectedEdges = [];\n      }\n    },\n\n    hideAll: function() {\n      for (var i in this.editor.patchList) {\n        var patch = this.editor.patchList[i];\n        patch.hide();\n      }\n    },\n\n    show: function() {\n\n      this.editor.deselectAll();\n\n      this.hideAll();\n\n      this.$edgeLayer.show();\n      this.$nodeLayer.show();\n\n      this.editor.currentPatch = this;\n\n      this.editor.emit(\"showPatch\", this.editor.currentPatch);    \n\n      this.editor.resize();\n    },\n\n    hide: function() {\n\n      this.$edgeLayer.hide();\n      this.$nodeLayer.hide();\n\n    },\n    \n    resize: function() {\n      var width = $(document).width(); // document instead of window? duh?\n      var height = $(document).height();\n      this.$edgeLayer.css({\n        width: width,\n        height: height\n      });\n      this.$edgeLayer[0].width = width;\n      this.$edgeLayer[0].height = height;\n      this.edgeContext.width = width;\n      this.edgeContext.height = height;\n      this.redrawEdges();\n    },\n\n    removeNodes: function(nodes) {\n      \n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        this.deselectNode(node);\n        this.nodeList.splice(this.nodeList.indexOf(node), 1);\n        node.$box.remove();\n      }\n\n    },\n\n    removeEdge: function(edge) {\n      this.edgeList.splice(this.edgeList.indexOf(edge), 1);\n      this.redrawEdges();\n    },\n\n    remove: function() {\n\n      var nodes = [];\n\n      var i, node;\n      for (i = 0; i < this.nodeList.length; i++) {\n        node = this.nodeList[i];\n        nodes.push(node);\n      }\n\n      for (i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.remove();\n      }\n      \n      this.$nodeLayer.remove();\n      this.$edgeLayer.remove();\n\n      this.parent.children.splice(this.parent.children.indexOf(this), 1);\n\n      delete(this.editor.patchList[this.id]);\n\n    }\n\n  };\n\n  registerCore({\n    name: \"Patch\",\n    core: Patch\n  });\n    \n});\n//@ sourceURL=/graph_editor/core/patch.js"),eval('/*global define:false */\ndefine(\'graph_editor/core/patch_node\',[\'register_node\', \'graph_editor/register_core\'], function(registerNode, registerCore) {\n  \n  var PatchNode = function(options) {\n    this._initPatchNode(options);\n  };\n  PatchNode.prototype = {\n\n    runtime: "Patch",\n\n    _initPatchNode: function(options) {\n\n      options.fill = "#FFF";\n      if (!options.patch_id) {\n        options.patch_id = parseInt(Math.random()*10000000,10).toString();\n      }\n\n      this.callSuper(options);\n\n      this.containedPatch = new this.editor.Patch({\n        id: options.patch_id,\n        parent: this.editor.patchList[options.patch]\n      });\n\n      this.editor.patchList[options.patch_id].node = this;\n\n    },\n\n    onRemove: function() {\n      this.containedPatch.remove();\n    }\n\n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "patch",\n    runtime: "Event",\n    node: PatchNode\n  });\n\n  registerCore({\n    name: "PatchNode",\n    core: PatchNode\n  });\n\n});\n//@ sourceURL=/graph_editor/core/patch_node.js'),eval('/*global define:false */\n/*global $:false */\ndefine(\'graph_editor/plugins/command_history\',[\'graph_editor/register_plugin\'], function(registerPlugin) {\n\n  var enabledOpacity = 1.0;\n  var disabledOpacity = 0.3;\n  \n  var CommandHistory = {\n\n    init: function(editor) {\n\n      this.editor = editor;\n\n      this.setupEventHandlers();\n\n    },\n\n    undo: function() {\n\n      var command = this.editor.commandHistoryList.pop();\n\n      if (command) {\n        command.undo();\n        this.$redo.css("opacity", enabledOpacity);\n        this.editor.commandFutureList.push(command);\n      }\n\n      if (this.editor.commandHistoryList.length === 0) {\n        this.$undo.css("opacity", disabledOpacity);\n      }\n\n    },\n\n    redo: function() {\n\n      var command = this.editor.commandFutureList.pop();\n\n      if (command) {\n        command.redo();\n        this.$undo.css("opacity", enabledOpacity);\n        this.editor.commandHistoryList.push(command);\n      }\n\n      if (this.editor.commandFutureList.length === 0) {\n        this.$redo.css("opacity", disabledOpacity);\n      }\n\n    },\n\n    setupEventHandlers: function() {\n\n      var that = this;\n\n      this.$ul = $(\'<ul class="command-history-controls"></ul>\');\n\n      this.$undo = $(\'<li class="undo"></li>\');\n      this.$undo.click(function() {\n        that.undo();\n      });\n\n      this.$redo = $(\'<li class="redo"></li>\');\n      this.$redo.click(function() {\n        that.redo();\n      });\n\n      this.$ul.append(this.$undo);\n      this.$ul.append(this.$redo);\n\n      this.$ul.appendTo($("#graph_editor"));\n\n      this.editor.on("newCommand", function() {\n        that.$undo.css("opacity", enabledOpacity);\n        that.$redo.css("opacity", disabledOpacity);\n      });\n      \n      var that = this;\n      \n      $(window).on("keyup", function(evt) {\n        evt.preventDefault();\n        if (evt.keyCode == 90 && evt.ctrlKey) { // z\n          if (evt.shiftKey) {\n            that.redo();\n          }\n          else {\n            that.undo();\n          }\n        }\n        return false;\n      });\n\n    }\n\n  };\n  \n  registerPlugin({\n    name: "command_history",\n    plugin: CommandHistory\n  });\n  \n});\n\n\n//@ sourceURL=/graph_editor/plugins/command_history.js'),eval("/*global define:false */\n/*global $:false */\n/*global window:false */\ndefine('graph_editor/plugins/copy_paste',['graph_editor/register_plugin'], function(registerPlugin) {\n  \n  var CopyPaste = {\n\n    init: function(editor) {\n      this.editor = editor;\n      this.setupEventHandlers();\n    },\n\n    cut: function() {\n      this.copy();\n      var selectedNodes = this.editor.currentPatch.selectedNodes;\n      var selectedEdges = this.editor.currentPatch.selectedEdges;\n      this.editor.removeNodes(selectedNodes, selectedEdges);\n    },\n\n    copy: function() {\n      var selectedNodes = this.editor.currentPatch.selectedNodes;\n      var selectedEdges = this.editor.currentPatch.selectedEdges;\n      var that = this;\n      this.editor.createGraphObject(selectedNodes, selectedEdges, function(graph_object) {\n        that.graph_object = graph_object;\n      });\n    },\n    \n    paste: function() {\n      if (!this.graph_object) {\n        return;\n      }\n      var duplicate_graph_object = this.duplicateGraphObject(this.graph_object);\n      this.editor.loadGraphObject(duplicate_graph_object);\n      \n      var i;\n      var createdNodeIds = [];\n      for (i = 0; i < duplicate_graph_object.nodes.length; i++) {\n        createdNodeIds.push(duplicate_graph_object.nodes[i].id);\n      }\n      \n      var allNodes = this.editor.allNodes();\n      for (i = 0; i < allNodes.length; i++) {\n        var node = allNodes[i];\n        if (createdNodeIds.indexOf(node.id) != -1) {\n          this.editor.currentPatch.selectNode(node, false, true);\n        }\n      }\n      \n    },\n    \n    duplicateGraphObject: function(graph_object_input) {\n      \n      var graph_object = $.extend({}, graph_object_input);\n      \n      var nodeMap = {};\n      \n      var nodes = graph_object.nodes\n      \n      var i;\n      for (i = 0; i < nodes.length; i++) {\n        var node_options = nodes[i];\n        var id = parseInt(Math.random(1)*10000000,10).toString();\n        nodeMap[node_options.id] = id;\n        node_options.id = id;\n        node_options.x += 60;\n        node_options.y += 60;\n      }\n      \n      var edges = graph_object.edges;\n      for (i = 0; i < edges.length; i++) {\n        \n        var edge_option = edges[i];\n        var source_id = edge_option.source_id;\n        var destination_id = edge_option.destination_id;\n        \n        if (nodeMap[source_id]) {\n          edge_option.source_id = nodeMap[source_id];\n        }\n        if (nodeMap[destination_id]) {\n          edge_option.destination_id = nodeMap[destination_id];\n        }\n        \n      }\n      // var comments = graph_object.comments;\n      // for (i = 0; i < comments.length; i++) {\n      // \n      // }\n\n      var worker_attributes = graph_object.worker_attributes;\n      for (var runtime_name in worker_attributes) {\n        var runtime_worker_attributes = worker_attributes[runtime_name];\n        for (var k = 0; k < runtime_worker_attributes.length; k++) {\n          var worker_attribute = runtime_worker_attributes[k];\n          if (nodeMap[worker_attribute.id]) {\n            worker_attribute.id = nodeMap[worker_attribute.id];\n          }\n        }\n      }\n      \n      return graph_object;\n\n    },\n\n    setupEventHandlers: function() {\n\n      var that = this;\n      \n      $(window).on(\"keyup\", function(evt) {\n        evt.preventDefault();\n        if (evt.keyCode == 67 && evt.ctrlKey) { // c\n          that.copy();\n        }\n        if (evt.keyCode == 86 && evt.ctrlKey) { // v\n          that.paste();\n        }\n        return false;\n      });\n\n    }\n\n  };\n  \n  registerPlugin({\n    name: \"copy_paste\",\n    plugin: CopyPaste\n  });\n  \n});\n\n\n//@ sourceURL=/graph_editor/plugins/copy_paste.js"),eval('/*global define:false */\n/*global document:false */\n/*global $:false */\ndefine(\'graph_editor/plugins/create_edge\',[\'graph_editor/register_plugin\'], function(registerPlugin) {\n  \n  var CreateEdge = {\n\n    init: function(editor) {\n\n      this.editor = editor;      \n      this.setupEventHandlers();\n      \n    },\n    \n    setupEventHandlers: function() {\n      \n      var that = this;\n      \n      this.editor.on("nodeInputMouseUp", function(input) {\n        that.inputMouseUp(input.node, input.name);\n      });\n      \n      this.editor.on("nodeInputMouseDown", function(input) {\n        var edge = that.editor.findEdgeByInput(input);\n        that.inputMouseDown(input.node, input.name, edge);\n      });\n      \n      this.editor.on("nodeInputTouchStart", function(input) {\n        var edge = that.editor.findEdgeByInput(input);\n        that.inputTouchStart(input.node, input.name, edge);\n      });\n      \n      this.editor.on("nodeInputTouchEnd", function(input) {\n        that.inputTouchEnd(input.node, input.name);\n      });\n      \n      this.editor.on("nodeOutputMouseDown", function(output) {\n        that.outputMousedown(output.node, output.name);\n      });\n      \n      this.editor.on("nodeOutputTouchStart", function(output) {\n        that.outputTouchStart(output.node, output.name);\n      });\n      \n    },\n\n    outputTouchStart: function(source, output_name, initialEndX, initialEndY) {\n      this.isDrawing = true;\n      this.editor.emit("edgeIsDrawing");\n      this.source = source;\n      this.output_name = output_name;\n\n      var startX = this.source.outputs[output_name].getX();\n      var startY = this.source.outputs[output_name].getY();\n\n      this.output = this.source.outputs[this.output_name];\n\n      this.isTouchSelecting = true;\n\n      this.startDrawingTouchEdge(startX, startY, initialEndX, initialEndY);\n\n    },\n    \n    inputTouchStart: function(destination, input_name, edge) {\n      if (edge) {\n        var source = edge.source;\n        var output_name = edge.output_name;\n\n        var initialEndX = destination.inputs[input_name].getX();\n        var initialEndY = destination.inputs[input_name].getY();\n\n        this.editor.disconnect(edge);\n        this.outputTouchStart(source, output_name, initialEndX, initialEndY);\n\n      }\n    },\n\n    inputTouchEnd: function(destination, input_name) {\n      if (this.isDrawing) {\n        this.editor.emit("edgeEndDrawing");\n        this.isDrawing = false;\n        var edge = this.source.connect(destination, this.output_name, input_name);\n        this.output = this.source.outputs[this.output_name];\n        this.editor.$stage.off("touchmove");\n        this.editor.$stage.off("touchend");\n        this.editor.currentPatch.selectEdge(edge);\n      }\n    },\n\n    startDrawingTouchEdge: function(startX, startY) {\n      var context = this.editor.currentPatch.edgeContext;\n      this.editor.currentPatch.redrawEdges();\n      \n      var that = this;\n\n      var screenX, screenY;\n      var pageX, pageY;\n      \n      var drawEdge = function(endX, endY) {\n        that.editor.currentPatch.redrawEdges();\n        context.strokeStyle=\'#30e8ca\';\n        context.lineWidth = 3;\n        context.lineCap = "round";\n        context.beginPath();\n        context.moveTo(startX, startY);\n        context.bezierCurveTo(startX + 60, startY, endX - 60, endY, endX, endY);\n        context.stroke();\n      };\n      \n      this.editor.$stage.on("touchmove", function(evt) {\n        \n        evt.preventDefault();\n        \n        pageX = evt.pageX || evt.originalEvent.pageX || evt.originalEvent.touches[0].pageX;\n        var endX = pageX - that.editor.$stage.offset().left;\n        pageY = evt.pageY || evt.originalEvent.pageY || evt.originalEvent.touches[0].pageY;\n        var endY = pageY - that.editor.$stage.offset().top;\n        \n        if (evt.originalEvent.pageX === 0) { // temp hack for bug in Chrome for Android\n          screenX = evt.originalEvent.touches[0].screenX;\n          screenY = evt.originalEvent.touches[0].screenY;\n        }\n        \n        drawEdge(endX, endY);\n        \n      });\n      \n      this.editor.$stage.on("touchend", function(evt) {\n        that.editor.$stage.off("touchmove");\n        that.editor.$stage.off("touchend");\n        that.editor.currentPatch.redrawEdges();\n        var e;\n        if (screenX) { // temp hack for bug in Chrome for Android\n          e = document.elementFromPoint(screenX, screenY);\n        }\n        else {\n          e = document.elementFromPoint(pageX, pageY);\n        }\n        $(e).trigger("touchend", evt); // this trigger needs to be after $stage.off("touchmove") or it will cause an infinite loop!\n      });\n\n    },\n\n    outputMousedown: function(source, output_name, initialEndX, initialEndY) {\n      this.isDrawing = true;\n      this.editor.emit("edgeIsDrawing");\n      this.source = source;\n      this.output_name = output_name;\n      var that = this;\n\n      var startX = this.source.outputs[output_name].getX();\n      var startY = this.source.outputs[output_name].getY();\n\n      this.startDrawingMouseEdge(startX, startY, initialEndX, initialEndY);\n\n      this.editor.currentPatch.selectNode(source); // will trigger node state change\n\n      this.editor.$stage.on("mouseup", function() {\n        if (that.isDrawing) {\n          that.cancelEdge();\n        }\n      });\n\n    },\n\n    inputMouseUp: function(destination, input_name) {\n      this.editor.$stage.off("mousemove");\n      this.editor.$stage.off("mouseup");\n      $(document).off("selectstart");\n      document.body.style.cursor = "";\n      this.editor.currentPatch.redrawEdges();\n      if (this.isDrawing) {\n        this.isDrawing = false;\n        this.editor.emit("edgeEndDrawing");\n        var edge = this.editor.connect({\n          source_id: this.source.id,\n          destination_id: destination.id,\n          input_name: input_name,\n          output_name: this.output_name\n        });\n        if (!edge) {\n          this.cancelEdge();\n          return;\n        }\n        this.editor.currentPatch.selectEdge(edge);\n      }\n    },\n    \n    inputMouseDown: function(destination, input_name, edge) {\n      if (edge) {\n        var source = edge.source;\n        var output_name = edge.output_name;\n        \n        var initialEndX = destination.inputs[input_name].getX();\n        var initialEndY = destination.inputs[input_name].getY();\n        \n        this.editor.disconnect(edge);\n        this.outputMousedown(source, output_name, initialEndX, initialEndY);\n\n      }\n    },\n\n    startDrawingMouseEdge: function(startX, startY, initialEndX, initialEndY) {\n      var context = this.editor.currentPatch.edgeContext;\n      this.editor.currentPatch.redrawEdges();\n\n      var that = this;\n      \n      $(document).on("selectstart", function() { return false; });\n      document.body.style.cursor = "pointer";\n      \n      var drawEdge = function(endX, endY) {\n        that.editor.currentPatch.redrawEdges();\n        context.strokeStyle=\'#30e8ca\';\n        context.lineWidth = 3;\n        context.lineCap = "round";\n        context.beginPath();\n        context.moveTo(startX, startY);\n        context.bezierCurveTo(startX + 60, startY, endX - 60, endY, endX, endY);\n        context.stroke();\n      };\n      \n      if (initialEndX && initialEndY) {\n        drawEdge(initialEndX, initialEndY);\n      }\n\n      this.editor.$stage.on("mousemove", function(evt) {\n        var endX = evt.pageX - that.editor.$stage.offset().left;\n        var endY = evt.pageY - that.editor.$stage.offset().top;\n        drawEdge(endX, endY);\n      });\n      \n      this.editor.$stage.on("mouseup", function() {\n        $(document).off("selectstart");\n        document.body.style.cursor = "";\n        that.editor.$stage.off("mousemove");\n        that.editor.$stage.off("mouseup");\n        that.editor.currentPatch.redrawEdges();\n      });\n\n    },\n\n    cancelEdge: function() {\n      this.editor.$stage.off("mouseup touchend");\n      this.isDrawing = false;\n      this.editor.emit("edgeEndDrawing");\n      this.output_name = null;\n      this.source = null;\n    }\n\n  };\n\n  registerPlugin({\n    name: "create_edge",\n    plugin: CreateEdge\n  });\n  \n});\n//@ sourceURL=/graph_editor/plugins/create_edge.js'),eval('/*global define:false */\n/*global $:false */\n/*global FileReader:false */\ndefine(\'graph_editor/plugins/media_drop\',[\'graph_editor/register_plugin\'], function(registerPlugin) {\n  \n  var MediaDrop = {\n\n    init: function(editor) {\n      this.editor = editor;\n      this.element = $("body");\n      this.setupEventHandlers();\n    },\n\n    setupEventHandlers: function() {\n      var that = this;\n      var stopDropAndRoll = function(event) {\n        event.stopPropagation();\n        event.preventDefault();\n      };\n\n      this.element.on("dragenter", stopDropAndRoll);\n      this.element.on("dragexit", stopDropAndRoll);\n      this.element.on("dragover", stopDropAndRoll);\n      this.element.on("drop", function(event) {\n        stopDropAndRoll(event);\n        that.dropEvent(event);\n      });\n\n    },\n\n    dropEvent: function(event) {\n\n      var dropX = event.originalEvent.offsetX;\n      var dropY = event.originalEvent.offsetY;\n\n      var dataTransfer = event.originalEvent.dataTransfer;\n\n      if (dataTransfer.files.length > 0) {\n\n        for (var i=0; i < dataTransfer.files.length; i++) {\n          var file = dataTransfer.files[i];\n          if (file.type.slice(0,5) == "audio") {\n            this.handleAudioFile(file, event, dropX, dropY, i);\n          }\n          else if (file.type.slice(0,5) == "image") {\n            this.handleImageFile(file, event, dropX, dropY, i);\n          }\n        }\n\n      }\n\n      return false;\n    },\n\n    handleImageFile: function(file, event, dropX, dropY, i) {\n\n      var image_file_node = this.editor.createNode({\n        type: \'image file\',\n        x: dropX,\n        y: dropY + (i * 60),\n        patch: this.editor.currentPatch.id\n      });\n\n      var reader = new FileReader();\n\n      var that = this;\n\n      // init the reader event handlers\n      reader.onloadend = function(evt) {\n        var url = evt.target.result;\n\n        var options = {\n          runtime: "Animation",\n          worker_id: image_file_node.id,\n          input_name: "url",\n          value: url\n        };\n        var json_options = JSON.stringify(options);\n        that.editor.emit("setWorkerAttribute", json_options);\n\n        if (event.originalEvent.altKey) {\n          var sprite_node = that.editor.createNode({\n            type: \'sprite\',\n            x: dropX + 150,\n            y: dropY + (i * 60),\n            patch: that.editor.currentPatch.id\n          });\n\n          that.editor.connect({\n            source_id: image_file_node.id,\n            destination_id: sprite_node.id,\n            input_name: "image",\n            output_name: "image"\n          });\n\n        }\n\n      };\n      reader.readAsDataURL(file);\n      \n      this.saveFile({\n        file: file\n      });\n\n    },\n\n    handleAudioFile: function(file, event, dropX, dropY, i) {\n      var audio_file_node = this.editor.createNode({\n        type: \'audio file\',\n        x: dropX,\n        y: dropY + (i * 60),\n        patch: this.editor.currentPatch.id\n      });\n\n      if (event.originalEvent.altKey) {\n        var audio_output_node = this.editor.createNode({\n          type: \'audio output\',\n          x: dropX + 150,\n          y: dropY + (i * 60),\n          patch: this.editor.currentPatch.id\n        });\n\n        this.editor.connect({\n          source_id: audio_file_node.id,\n          destination_id: audio_output_node.id,\n          input_name: "audio_in",\n          output_name: "audio_out"\n        });\n\n      }\n\n      var that = this;\n\n      var reader = new FileReader();\n      reader.onloadend = function(event) {\n        var buffer = event.target.result;\n        \n        var options = {\n          runtime: "Audio",\n          worker_id: audio_file_node.id,\n          input_name: "buffer",\n          value: buffer\n        };\n        \n        that.editor.emit("setArrayBufferWorkerAttribute", options); // notice that this isn\'t JSON...\n        // we are gonna move over to window.postMessage at some point!\n        // http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast\n        // http://updates.html5rocks.com/2011/09/Workers-ArrayBuffer\n        \n      };\n      reader.readAsArrayBuffer(file);\n      \n      this.saveFile({\n        file: file\n      });\n\n    },\n    \n    saveFile: function() {\n      \n      // STUB\n      \n      // https://hacks.mozilla.org/2012/02/saving-images-and-files-in-localstorage/\n      // http://hacks.mozilla.org/2012/02/storing-images-and-files-in-indexeddb/\n      \n    }\n\n  };\n\n  registerPlugin({\n    name: "media_drop",\n    plugin: MediaDrop\n  });\n  \n});\n//@ sourceURL=/graph_editor/plugins/media_drop.js'),eval("/*global define:false */\n/*global $:false */\n/*global window:false */\n/*global document:false */\ndefine('graph_editor/plugins/new_node',['graph_editor/register_plugin'], function(registerPlugin) {\n  \n  var NewNode = {\n\n    init: function(editor) {\n\n      this.editor = editor;\n\n      this.createPopup();\n      \n      var that = this;\n\n      $(window).on(\"keyup\", function(evt) {\n        if (that.editor.modalWindowOpen) {\n          return;\n        }\n\n        // ctrl+n\n        if (evt.keyCode == 78 && evt.ctrlKey) { // this guy should register as a plugin and then request this keyboard command\n          that.show();\n        }\n        // esc\n        if (evt.keyCode == 27) {\n          if (that.visible()) {\n            that.hide();\n          }\n        }\n\n      });\n\n    },\n\n    createPopup: function() {\n\n      this.$popup = $('<div id=\"new_node\">');\n      this.$title = $('<h2>Add New Node</h2>');\n      this.$input = $('<input type=\"text\">');\n      this.$form = $('<form></form>');\n\n      this.$form.append(this.$input);\n\n      this.$popup.append(this.$title);\n      this.$popup.append(this.$form);\n\n      this.$popup.appendTo($(document.body));\n\n      var that = this;\n\n      this.$form.submit(function(event) {\n        event.preventDefault();\n        that.onSubmit();     \n        return false;\n      });\n\n    },\n\n    onSubmit: function() {\n\n      var type = this.$input.val();\n\n      if( !$.trim(type).length ) {\n        return;\n      }\n\n      var node = this.editor.createNode({\n        type: type,\n        x: this.editor.mouseX,\n        y: this.editor.mouseY,\n        patch: this.editor.currentPatch.id\n      });\n\n      this.editor.currentPatch.selectNode(node);\n\n      this.hide();\n    },\n\n    show: function() {\n      this.editor.modalWindowOpen = true;\n      this.$popup.css({\n        left: this.editor.mouseX,\n        top: this.editor.mouseY\n      });\n      this.$popup.show();\n      this.$input.focus();\n\n    },\n\n    hide: function() {\n      this.editor.modalWindowOpen = false;\n      this.$input.val(\"\");\n      this.$popup.hide();\n    },\n\n    visible: function() {\n      return this.$input.is(':visible');\n    }\n\n  };\n\n  registerPlugin({\n    name: \"new_node\",\n    plugin: NewNode\n  });\n  \n});\n//@ sourceURL=/graph_editor/plugins/new_node.js"),eval('/*global define:false */\n/*global $:false */\n/*global Image:false */\ndefine(\'graph_editor/plugins/runtime_display\',[\'graph_editor/register_plugin\'], function(registerPlugin) {\n  \n  var RunTimeDisplay = {\n\n    init: function(editor) {\n\n      this.editor = editor;\n\n      this.$container = $("<ul />");\n      this.$container.addClass("runtime-menu");\n\n      this.editor.$menu.append(this.$container);\n      this.editor.$menu.append($("<div style=\'clear: both;\'/>"));\n\n      var logo = new Image();\n      logo.src = "images/moon_surface.png";\n      $(logo).addClass("logo");\n      this.$container.append(logo);\n\n      this.loadRuntimeDisplays();\n\n      var that = this;\n\n      $(".create-node").click(function() {\n\n        var type = $(this).text();\n\n        var node = that.editor.createNode({\n          type: type,\n          x: 300,\n          y: 300,\n          patch: that.editor.currentPatch.id\n        });\n\n        that.editor.currentPatch.selectNode(node);\n\n      });\n\n    },\n\n    loadRuntimeDisplays: function() {\n      \n      var runtime_list = this.editor.runtimeList;\n      \n      for (var runtime_name in runtime_list) {\n        var runtime = runtime_list[runtime_name];\n        if (runtime.display) {\n          this.loadRuntimeDisplay(runtime);\n        }\n      }\n    },\n\n    loadRuntimeDisplay: function(runtime) {\n\n      var height = 34;\n\n      var $li = $("<li />");\n      $li.css({\n        \'box-shadow\': "0px 0px 20px 0px " + runtime.color + " inset"\n      });\n      $li.addClass("runtime-item");\n      var icon = new Image();\n      icon.src = runtime.icon_src;\n      var $icon = $(icon);\n      $icon.addClass("icon");\n\n      icon.onload = function() {\n        var dif = height - icon.height;\n        $icon.css({\n          "padding-top": dif/2,\n          "padding-bottom": dif/2\n        });\n      };\n      $li.append(icon);\n\n      var $ul = this.generateMenu(runtime);\n\n      $li.append($ul);\n\n      this.$container.append($li);\n\n    },\n\n    generateMenu: function(runtime) {\n\n      var $ul = $("<ul />");\n      $ul.addClass("runtime-item-menu");\n      $ul.addClass(runtime.name);\n\n      var runtime_nodes = this.getNodesByRuntime(runtime);\n\n      for (var runtime_node_name in runtime_nodes) {\n        var $li = $("<li />");\n        $li.addClass("create-node");\n        $li.text(runtime_node_name);\n        $ul.append($li);\n      }\n\n      return $ul;\n\n    },\n\n    getNodesByRuntime: function(runtime) {\n      var nodes = {};\n      for (var n in this.editor.nodeTypes) {\n        var nodeType = this.editor.nodeTypes[n];\n        if (nodeType.prototype.runtime == runtime.name) {\n          nodes[n] = nodeType;\n        }\n      }\n      return nodes;\n    }\n\n  };\n\n  registerPlugin({\n    name: "runtime_display",\n    plugin: RunTimeDisplay\n  });\n  \n});\n//@ sourceURL=/graph_editor/plugins/runtime_display.js'),eval('/*global define:false */\n/*global $:false */\n/*global window:false */\ndefine(\'graph_editor/plugins/selection_box\',[\'graph_editor/register_plugin\'], function(registerPlugin) {\n  \n  var SelectionBox = {\n\n    init: function(editor) {\n\n      this.editor = editor;\n      this.createSelectionBox();\n      this.setupEventHandlers();\n\n    },\n    \n    createSelectionBox: function() {\n      this.$box = $("<div />");\n      this.$box.css({\n        position: "fixed",\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        \'background-color\': "rgba(255,255,255,0.3)",\n        \'z-index\': 100\n      });\n      this.$box.appendTo(this.editor.$stage);\n    },\n    \n    setupEventHandlers: function() {\n      \n      var that = this;\n      this.editor.$stage.on("mousedown", function(event) {\n        var x = event.clientX;\n        var y = event.clientY;\n        that.startSelection(x, y);\n        \n        $(window).on("mousemove", function(event) {\n          if (that.isSelecting) {\n            var x = event.clientX;\n            var y = event.clientY;\n            that.drawSelectionBox(x, y);\n          }\n        });\n        \n        $(window).one("mouseup", function() {\n          $(window).off("mousemove");\n          that.endSelection();\n        });\n        \n      });\n      \n    },\n    \n    startSelection: function(x, y) {\n      this.editor.disableMouseoverInput = true;\n      this.isSelecting = true;\n      this.startX = x;\n      this.startY = y;\n      this.$box.css({\n        left: this.startX,\n        top: this.startY\n      });\n    },\n    \n    drawSelectionBox: function(dX, dY) {\n      \n      var width = dX - this.startX;\n      var height = dY - this.startY;\n      \n      var x = this.startX;\n      var y = this.startY;\n      \n      if (width <= 0) {\n        x = this.startX + width;\n        width = -width;\n      }\n      \n      if (height <= 0) {\n        y = this.startY + height;\n        height = -height;\n      }\n      \n      this.$box.css({\n        left: x,\n        top: y,\n        width: width,\n        height: height\n      });\n      \n      this.detectCollisions();\n      \n      //console.log("draw", x, y);\n    },\n    \n    detectCollisions: function() {\n      \n      var collisionNodes = [];\n      \n      var b_x = this.$box.offset().left;\n      var b_y = this.$box.offset().top;\n      var b_w = parseInt(this.$box.css("width"), 10);\n      var b_h = parseInt(this.$box.css("height"), 10);\n      \n      var nodes = this.editor.allNodes();\n\n      var i;\n      for (i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (this.isNodeInSelectionBox(node, b_x, b_y, b_h, b_w)) {\n          collisionNodes.push(node);\n          this.editor.currentPatch.selectNode(node, false, true);\n        }\n      }\n      \n      var selectedNodes = this.editor.currentPatch.selectedNodes;\n      \n      for (i = 0; i < selectedNodes.length; i++) {\n        var selectedNode = selectedNodes[i];\n        \n        if (collisionNodes.indexOf(selectedNode) == -1) {\n          this.editor.currentPatch.deselectNode(selectedNode);\n        }\n        \n      }\n      \n\n    },\n    \n    isNodeInSelectionBox: function(node, b_x, b_y, b_h, b_w) {\n      var n_x = node.$box.offset().left;\n      var n_y = node.$box.offset().top;\n      var n_w = parseInt(node.$box.css("width"), 10);\n      var n_h = parseInt(node.$box.css("height"), 10);\n                      \n      var collision = !(n_x > b_x+b_w || \n                        n_x+n_w < b_x || \n                        n_y > b_y+b_h ||\n                        n_y+n_h < b_y);\n      \n      return collision;\n    },\n    \n    endSelection: function() {\n      this.editor.disableMouseoverInput = false;\n      this.$box.css({\n        width: 0,\n        height: 0\n      });\n      this.isSelecting = false;\n    }\n\n  };\n  \n  registerPlugin({\n    name: "selection_box",\n    plugin: SelectionBox\n  });\n  \n});\n\n\n//@ sourceURL=/graph_editor/plugins/selection_box.js'),eval('/*global define:false */\n/*global $:false */\n/*global setTimeout:false */\ndefine(\'graph_editor/plugins/sidebar\',[\'graph_editor/register_plugin\'], function(registerPlugin) {\n  \n  var Sidebar = {\n\n    init: function(editor) {\n\n      this.editor = editor;\n\n      this.$container = $(\'<ul id="sidebar" />\');\n      this.$container.appendTo(this.editor.$element);\n      \n      this.createItem("wave", "lfo");\n      this.createItemPopup("image", "image file");\n      this.createItem("box", "sprite");\n      this.createItem("pointer", "mouse input");\n      //this.createItem("keys", "keys");\n      this.createItem("text", "text");\n      this.createItem("color", "hsla");\n      this.createItem("math", "math");\n      //this.createItem("counter", "counter");\n\n    },\n    \n    createItem: function(title, node_type) {\n      \n      var $item = $(\'<li />\');\n      $item.addClass(node_type.replace(" ", "-"));\n      \n      $item.text(title);\n      \n      var that = this;\n      \n      $item.click(function() {\n      \n        var node = that.editor.createNode({\n          titleText: title,\n          type: node_type,\n          x: 300,\n          y: 300,\n          patch: that.editor.currentPatch.id\n        });\n      \n        that.editor.currentPatch.selectNode(node);\n      \n      });\n      \n      \n      $item.appendTo(this.$container);\n      \n    },\n    \n    createItemPopup: function(title, node_type) {\n      \n      var $item = $(\'<li />\');\n      $item.addClass(node_type.replace(" ", "-"));\n      \n      $item.text(title);\n      \n      var that = this;\n      \n      $item.click(function() {\n      \n        var $dnd = $(\'<div />\');\n        $dnd.addClass(\'drag-n-drop-message\');\n        $dnd.text("Drag-and-drop images from your computer to add them to this Project!");\n        that.editor.$stage.append($dnd);\n        \n        setTimeout(function() {\n          $dnd.fadeOut();\n        }, 2700);   \n      \n      });\n      \n      \n      $item.appendTo(this.$container);\n      \n    }\n\n  };\n\n  registerPlugin({\n    name: "sidebar",\n    plugin: Sidebar\n  });\n  \n});\n//@ sourceURL=/graph_editor/plugins/sidebar.js'),eval('define(\'runtimes/event\',[\'runtimes/register_runtime\',\'lib/extend\', \'runtimes/runtime_manager\'], function(registerRuntime, extend, RuntimeManager) {\n  \n  var Event = {\n\n    name: "Event",\n    color: "white",\n\n    workers: {}, // make this an array\n    workerTypes: {}, // make this an array\n    registeredNodeInstances: {}, // make this an array\n    \n    init: function(options) {\n      this.runtime_manager = options.runtime_manager;\n    },\n\n    registerWorker: function(worker, type) {\n      extend(worker, EventWorker);\n      this.workerTypes[type] = worker;\n    },\n\n    registerInstance: function(node) {\n      this.registeredNodeInstances[node.id] = node;\n    },\n\n    unregisterInstance: function(node) {\n      delete(this.registeredNodeInstances[node.id]);\n    },\n\n    clearAll: function() {\n      var w;\n      for (w in this.workers) {\n        delete(this.workers[w]);\n      }\n      this.workers = {};\n      for (w in this.registeredNodeInstances) {\n        delete(this.registeredNodeInstances[w]);\n      }\n      this.registeredNodeInstances = {};\n    },\n\n    create: function(node) {\n      var workerType = this.workerTypes[node.type];\n      if (!workerType) {\n        return;\n      }\n      var worker = new workerType({\n        id: node.id\n      });\n      worker.triggers = {};\n      this.workers[worker.id] = worker;\n      return worker;\n    },\n\n    remove: function(worker) {\n      delete(this.workers[worker.id]);\n    },\n\n    connect: function(edge) {\n\n      var source, destination, registeredNode, runtime_name, runtime;\n      \n      if (this.workers[edge.destination_id]) {\n        destination = this.workers[edge.destination_id];\n      }\n      else {\n        registeredNode = this.registeredNodeInstances[edge.destination_id];\n        runtime_name = registeredNode.runtime;\n        runtime = this.runtime_manager.findByName(runtime_name);\n        destination = runtime.workers[edge.destination_id];\n        if (!destination && runtime.findWorkerById) {\n          destination = runtime.findWorkerById(edge.destination_id);\n        }\n      }\n\n      if (this.workers[edge.source_id]) {\n        source = this.workers[edge.source_id];\n      }\n      else {\n        registeredNode = this.registeredNodeInstances[edge.source_id];\n        runtime_name = registeredNode.runtime;\n        runtime = this.runtime_manager.findByName(runtime_name);\n        source = runtime.workers[edge.source_id];\n        if (!source && runtime.findWorkerById) {\n          source = runtime.findWorkerById(edge.source_id);\n        }\n      }\n\n\n      var input_name = edge.input_name;\n      var input = destination.eventInputs[input_name];\n\n      var output_name = edge.output_name;\n\n      if (!source.triggers[output_name]) {\n        source.triggers[output_name] = [];\n      }\n\n      if (input && input.connect_point) {\n        //console.log("input.options.connect_point exists, creating trigger");\n        var trigger = {\n          connect_point: function(event) {\n            //console.log("trigger - ","source", source.id, "destination", destination.id);\n            input.connect_point(event);\n          },\n          edge: edge\n        };\n        source.triggers[output_name].push(trigger);\n      }\n\n    },\n\n    disconnect: function(edge) {\n\n      var source, destination, registeredNode, runtime_name, runtime;\n      \n      if (this.workers[edge.destination_id]) {\n        destination = this.workers[edge.destination_id];\n      }\n      else {\n        registeredNode = this.registeredNodeInstances[edge.destination_id];\n        runtime_name = registeredNode.runtime;\n        runtime = this.runtime_manager.findByName(runtime_name);\n        destination = runtime.workers[edge.destination_id];\n        if (!destination && runtime.findWorkerById) {\n          destination = runtime.findWorkerById(edge.destination_id);\n        }\n      }\n\n      if (this.workers[edge.source_id]) {\n        source = this.workers[edge.source_id];\n      }\n      else {\n        registeredNode = this.registeredNodeInstances[edge.source_id];\n        runtime_name = registeredNode.runtime;\n        runtime = this.runtime_manager.findByName(runtime_name);\n        source = runtime.workers[edge.source_id];\n        if (!source && runtime.findWorkerById) {\n          source = runtime.findWorkerById(edge.source_id);\n        }\n      }\n\n      var output_name = edge.output_name;\n\n      var triggers = source.triggers[output_name];\n\n      for (var i = 0; i < triggers.length; i++) {\n        var trigger = triggers[i];\n        if (trigger.edge.source_id == edge.source_id && trigger.edge.output_name == edge.output_name) {\n          source.triggers[output_name].splice(source.triggers[output_name].indexOf(trigger), 1);\n        }\n      }\n\n    },\n\n    // START STUB\n    setWorkerAttribute: function(options) {\n      var worker = this.workers[options.worker_id];\n      //console.log(worker);\n    },\n    getWorkerAttribute: function(options) {\n      var worker = this.workers[options.worker_id];\n      return worker.inputAttributes[options.input_name];\n    },\n    // END STUB\n\n    allWorkersAttributes: function() {\n      var workers = [];\n      for (var i in this.workers) {\n        var worker = this.workers[i];\n        if (worker.inputAttributes && worker.outputAttributes) {\n          var worker_attributes = {\n            id: worker.id,\n            inputAttributes: this.sanitizeAttributes(worker.inputAttributes),\n            outputAttributes: this.sanitizeAttributes(worker.outputAttributes)\n          };\n          workers.push(worker_attributes);\n        }\n      }\n      return workers;\n    },\n\n    sanitizeAttributes: function(attributes) {\n      var sanitized_attributes = {};\n      for (var a in attributes) {\n        var attribute = attributes[a];\n        if (typeof(attribute) == "string" || typeof(attribute) == "number") {\n          sanitized_attributes[a] = attribute;\n        }\n      }\n      return sanitized_attributes;\n    },\n\n    parse: function(workers_attributes) {\n      \n      var i;\n      for (i=0; i < workers_attributes.length; i++) {\n        var worker_attributes = workers_attributes[i];\n        var worker = this.workers[worker_attributes.id];\n        worker.inputAttributes = worker_attributes.inputAttributes;\n        worker.outputAttributes = worker_attributes.outputAttributes;\n\n        var function_name;\n        for (i in worker.inputAttributes) {\n          function_name = "set" + i[0].toUpperCase() + i.slice(1,i.length);\n          if (worker[function_name]) {\n            worker[function_name](worker.inputAttributes[i]);\n          }\n        }\n\n        for (i in worker.outputAttributes) {\n          function_name = "set" + i[0].toUpperCase() + i.slice(1,i.length);\n          if (worker[function_name]) {\n            worker[function_name](worker.outputAttributes[i]);\n          }\n        }\n\n      }\n    },\n\n    trigger: function(edge) {\n\n      if (edge.source.triggers[edge.output_name]) {\n        for (var i = 0; i < edge.source.triggers[edge.output_name].length; i++) {\n          var trigger = edge.source.triggers[edge.output_name][i];\n          trigger.connect_point(edge.event);\n\n          var destination_id = trigger.edge.destination_id;\n          var input_name = trigger.edge.input_name;\n\n          var runtime = this.runtime_manager.findByName(\'Event\').registeredNodeInstances[destination_id].runtime;\n\n          var destination = this.runtime_manager.findByName(runtime).workers[destination_id];\n\n          destination.inputAttributes[input_name] = edge.event;\n        }\n      }\n\n      var event = edge.event;\n      event.node_id = edge.source.id;\n\n    }\n\n  };\n  \n  var EventWorker = function(options) {\n    this._initWorker(options);\n  };\n\n  EventWorker.prototype = {\n\n    _initWorker: function(options) {\n      \n      this.id = options.id;\n      this.eventInputs = {};\n      this.eventOutputs = {};\n      this.events = {};\n\n      this.outputAttributes = {};\n      this.inputAttributes = {};\n      \n      this.canTrigger = true;\n      \n      var that = this;\n      this.timer = setInterval(function() {\n        that.canTrigger = true;\n      }, 33);\n\n    },\n\n    createEventInput: function(options) {\n      var input = {\n        connect_point: options.connect_point,\n        name: options.name\n      };\n      this.eventInputs[input.name] = input;\n      return input;\n    },\n\n    createEventOutput: function(options) {\n      var output = {\n        connect_point: options.connect_point,\n        name: options.name\n      };\n      this.eventOutputs[output.name] = output;\n      return output;\n    },\n\n    addEventListener: function(event_name, callback) {\n      this.events[event_name] = function(event) {\n        callback(event);\n      };\n    },\n    \n    throttledTriggerEvent: function(event) {\n    \n      if (this.canTrigger) {\n        this.triggerEvent(event);\n        this.canTrigger = false;\n      }\n      \n    },\n\n    triggerEvent: function(event) {\n      var that = this;\n      setTimeout(function() {\n        event.node_id = that.id;\n        RuntimeManager.triggerEvent(event);\n      }, 1);\n\n    }\n\n  };\n  \n  registerRuntime({\n    name: "Event",\n    runtime: Event,\n    worker: EventWorker\n  });\n  \n});\n//@ sourceURL=/runtimes/event.js'),eval('define(\'runtimes/animation\',[\'runtimes/register_runtime\',\'lib/extend\',\'runtimes/event\'], function(registerRuntime, extend) {\n\n  var Animation = {\n\n    name: "Animation",\n    color: "orange",\n    icon_src: "images/animation.png",\n\n    display: true,\n    \n    // iPhone is 960-by-640\n\n    _width: 288,\n    _height: 192,\n\n    edges: [],\n    workers: [],\n\n    workerTypes: {}, // make this an array\n\n    init: function(options) {\n      \n      this.viewer_background = options.viewer_background;\n      \n      if (this.viewer_background != "transparent") {\n        $(document.body).css("background-color", $("#stage").css("background-color"));\n      }\n      \n      if (options.width && options.height) {\n        this._width = options.width;\n        this._height = options.height;\n      }\n\n      \n      this.startTime = Date.now();\n      this.globalTime = 0.0;\n\n      this.initCanvas();\n\n      this.playing = true;\n      \n      var params = window.location.href.split("?")[1];\n      if (params) {\n        var params_array = params.split("&");\n        if (params_array.indexOf("fullscreen=true") != -1) {\n          this.didShowLoader = true;\n          this.fullScreenViewer();\n          this.showLoader();\n        }\n        if (params_array.indexOf("static=true") != -1) {\n          var that = this;\n          this.staticAnimation = true;   \n          \n          $(this.element).mouseenter(function() {\n            that.play();\n          });\n          \n          $(this.element).mouseleave(function() {\n            that.pause();\n          });\n          \n        }\n      }\n\n      this.runLoop(0);\n\n      this.setupEventHandlers();\n\n    },\n    \n    onProjectLoad: function() {\n      if (this.didShowLoader) {\n        this.hideLoader();\n      }\n      if (this.staticAnimation) {\n        this.pause();\n      }\n      \n    },\n    \n    showLoader: function() {\n      $(this.element).css({\n        opacity: 0\n      });\n      \n      this.$loader = $(\'<div />\');\n      this.$loader.text("LOADING");\n      this.$loader.css({\n        position: \'fixed\',\n        width: this._width,\n        height: this._height,\n        "text-align": \'center\',\n        "font-size": "45px",\n        "background-color": "black",\n        color: "white",\n        "line-height": this._height + "px"\n      });\n      this.$loader.appendTo($(document.body));\n    },\n    \n    hideLoader: function() {\n      $(this.element).css({\n        opacity: 1\n      });\n      \n      this.$loader.remove();\n    },\n\n    initCanvas: function() {\n      this.element = document.createElement(\'canvas\');\n      $(this.element).addClass("animation-viewer");\n      this.element.width = this._width;\n      this.element.height = this._height;\n      this.context = this.element.getContext(\'2d\');\n      this.context.clearRect(0,0,this._width,this._height);\n      $(document.body).append($(this.element));\n\n      if (this.canvasWasRemoved) {\n        for (var i=0; i < this.workers.length; i++) {\n          var worker = this.workers[i];\n          worker.context = this.context;\n        }\n        this.runLoop();\n      }\n\n    },\n\n    setupEventHandlers: function() {\n\n      var that = this;\n\n      $(window).on("keyup", function(evt) {\n\n        if (evt.keyCode == 70 && evt.ctrlKey) {\n          if (that.fullscreenMode) {\n            that.reattachViewer();\n          }\n          else {\n            that.fullScreenViewer();\n          }\n        }\n      });\n      \n      $(window).bind(\'orientationchange\', function(e, onready){\n        if (that.fullscreenMode) {\n          var width = $(window).width();\n          var height = $(window).height();\n          that.resizeViewer(width, height);\n        }\n      });\n\n    },\n\n    removeCanvasAndContext: function() {\n      this.context = null;\n      $(this.element).remove();\n      this.element = null;\n      this.canvasWasRemoved = true;\n    },\n\n    resizeViewer: function(width, height) {\n      this._width = width;\n      this._height = height;\n      this.element.width = width;\n      this.element.height = height;\n      $(this.element).css({\n        width: width,\n        height: height\n      });\n      this.context.width = width;\n      this.context.height = height;\n    },\n    \n    embedViewer: function() {\n      this.fullscreenMode = true;\n      var width = $(window).width();\n      var height = $(window).height() - 35;\n      this.resizeViewer(width, height);\n      if (this.viewer_background == "transparent") {\n        $("#graph_editor").hide(); // maybe... don\'t hide, just shift to the left?\n      }\n      $("#graph_editor").hide();\n      $(this.element).css({\n        position: "fixed",\n        top: 0,\n        right: 0,\n        border: 0//,\n        //"box-shadow": "0"\n      });\n    },\n\n    fullScreenViewer: function() {\n      this.fullscreenMode = true;\n      var width = $(window).width();\n      var height = $(window).height();\n      this.resizeViewer(width, height);\n      if (this.viewer_background == "transparent") {\n        $("#graph_editor").hide(); // maybe... don\'t hide, just shift to the left?\n      }\n      $("#graph_editor").hide();\n      $(this.element).css({\n        position: "fixed",\n        \'z-index\': 1000000,\n        top: 0,\n        right: 0,\n        border: 0//,\n        //"box-shadow": "0"\n      });\n    },\n\n    reattachViewer: function() {\n      $("#graph_editor").show();\n      this.fullscreenMode = false;\n      this.resizeViewer(288, 192);\n      $(this.element).css({\n        position: "fixed",\n        \'z-index\': 900,\n        top: 48,\n        right: 0,\n        border: "2px solid #352e3c"//,\n        //"box-shadow": "2px 8px 12px 4px rgba(0, 0, 0, 0.3)"\n      });\n    },\n\n    runLoop: function(timestamp) {\n\n      var debug = !this.playing;\n\n      if (debug) {\n        console.log("runLoop(" + timestamp + ")");\n      }\n\n      this.lastTimestamp = timestamp;\n\n      if (!this.context) {\n        return;\n      }\n      \n      this.globalTime = (timestamp - this.startTime) / 1000.0;\n      \n      //console.log("globalTime  ", this.globalTime);\n\n      this.context.clearRect(0,0,this._width,this._height);\n\n      var that = this;\n\n      for (var i=0; i < this.edges.length; i++) {\n        var edge = this.edges[i];\n\n        var destination = edge.destination;\n        var input_name = edge.input_name;\n\n        var source = edge.source;\n        var output_name = edge.output_name;\n\n        destination.inputAttributes[input_name] = source.outputAttributes[output_name];\n\n        if (debug) {\n          //console.log("edge", edge, "destination", destination, "input_name", input_name, "source", source, "output_name", output_name);\n          console.log(source.id, source.type, "source.outputAttributes[output_name]", source.outputAttributes[output_name]);\n        }\n\n      }\n\n      for (var n = 0; n < this.workers.length; n++) {\n        var worker = this.workers[n];\n        if (worker.runLoop) {\n          this.context.save();\n          if (debug) {\n            console.log("calling worker runLoop", worker.id, worker.type);\n          }\n          worker.runLoop(this.globalTime, debug);\n          this.context.restore();\n        }\n      }\n\n      if (this.playing) {\n        // window.setTimeout(function() {\n        //   var timestamp = Date.now();\n        //   that.runLoop(timestamp);\n        // }, 33);\n        requestAnimFrame(function(timestamp) {\n          that.runLoop(timestamp);\n        });\n      }\n\n    },\n    \n    snapshot: function() {\n      \n      var dataURL = this.element.toDataURL("image/png");\n      \n      return dataURL;\n      \n    },\n    \n    pause: function() {\n      this.playing = false;\n    },\n\n    play: function() {\n      this.playing = true;\n      this.runLoop(this.lastTimestamp);\n    },\n\n    step: function(ms) {\n      this.lastTimestamp += ms;\n      this.runLoop(this.lastTimestamp);\n    },\n\n    origin: function() {\n      return {\n        x: this._width/2,\n        y: this._height/2\n      };\n    },\n\n    tX: function(x) {\n      return (parseFloat(x) + 1) * (this._width/2);\n    },\n\n    tY: function(y) {\n      return ((parseFloat(-y) + (this._height/this._width)) * this._height/2) * this._width/this._height;\n    },\n\n    tW: function(w) {\n      return parseFloat(w) * this._width/2;\n    },\n\n    tH: function(h) {\n      return parseFloat(h) * this._height/2 * this._width/this._height;\n    },\n\n    translate: function(x,y,w,h) {\n      var t = {\n        x: this.tX(x) - this.tW(w)/2,\n        y: this.tY(y) - this.tH(h)/2,\n        w: this.tW(w),\n        h: this.tH(h)\n      };\n      return t;\n    },\n\n    registerWorker: function(worker, type) {\n      extend(worker, AnimationWorker);\n      this.workerTypes[type] = worker;\n      this.eventRuntime.registerWorker(worker, type);\n    },\n\n    findWorkerById: function(worker_id) {\n      for (var i=0; i < this.workers.length; i++) {\n        var worker = this.workers[i];\n        if (worker.id == worker_id) {\n          return worker;\n        }\n      }\n    },\n\n    findEdge: function(incoming_edge) {\n      for (var i=0; i < this.edges.length; i++) {\n        var edge = this.edges[i];\n        if (edge.source_id == incoming_edge.source_id && edge.destination_id == incoming_edge.destination_id && edge.input_name == incoming_edge.input_name && edge.output_name == incoming_edge.output_name) {\n          return edge;\n        }\n      }\n    },\n\n    clearAll: function() {\n      this.workers = [];\n      this.edges = [];\n    },\n\n    create: function(node) {\n      var workerType = this.workerTypes[node.type];\n      var worker = new workerType({\n        id: node.id\n      });\n      worker.type = node.type;\n      this.workers.push(worker);\n    },\n\n    remove: function(worker) {\n      worker = this.findWorkerById(worker.id);\n      this.workers.splice(this.workers.indexOf(worker), 1);\n    },\n\n    connect: function(edge) {\n      edge.source = this.findWorkerById(edge.source_id);\n      edge.destination = this.findWorkerById(edge.destination_id);\n      this.edges.push(edge);\n    },\n\n    disconnect: function(node_edge) {\n      var edge = this.findEdge(node_edge);\n      edge.destination.inputAttributes[edge.input_name] = null;\n      this.edges.splice(this.edges.indexOf(edge), 1);\n    },\n\n    setWorkerAttribute: function(options) {\n      var worker = this.findWorkerById(options.worker_id);\n      worker.inputAttributes[options.input_name] = options.value;\n    },\n\n    getWorkerAttribute: function(options) {\n      var worker = this.findWorkerById(options.worker_id);\n      return worker.inputAttributes[options.input_name];\n    },\n\n    getWorkerAttributes: function(options) {\n      var worker = this.findWorkerById(options.worker_id);\n      var return_object = {\n        worker_id: worker.id,\n        value: this.sanitizeAttributes(worker.inputAttributes)\n      };\n      return return_object;\n    },\n\n    allWorkersAttributes: function() {\n      var workers = [];\n      for (var i=0; i < this.workers.length; i++) {\n        var worker = this.workers[i];\n        var worker_attributes = {\n          id: worker.id,\n          inputAttributes: this.sanitizeAttributes(worker.inputAttributes),\n          outputAttributes: this.sanitizeAttributes(worker.outputAttributes)\n        };\n        workers.push(worker_attributes);\n      }\n      return workers;\n    },\n\n    sanitizeAttributes: function(attributes) {\n      var sanitized_attributes = {};\n      for (var a in attributes) {\n        var attribute = attributes[a];\n        if (attribute && attribute.length > 2000) {\n          return; // we don\'t want to save large attributes\n        }\n        if (typeof(attribute) == "string" || typeof(attribute) == "number") {\n          sanitized_attributes[a] = attribute;\n        }\n      }\n      return sanitized_attributes;\n    },\n\n    parse: function(workers_attributes) {\n      for (var i=0; i < workers_attributes.length; i++) {\n        var worker_attributes = workers_attributes[i];\n        var worker = this.findWorkerById(worker_attributes.id);\n        worker.inputAttributes = worker_attributes.inputAttributes;\n        if (worker_attributes.outputAttributes) {\n          worker.outputAttributes = worker_attributes.outputAttributes;\n        }\n      }\n    },\n    \n    getLayeredWorkers: function() {\n      var layered_workers = [];\n      \n      for (var i = 0; i < this.workers.length; i++) {\n        var worker = this.workers[i];\n        if (worker.layered) {\n          layered_workers.push(worker);\n        }\n      }\n      \n      return layered_workers;\n    },\n    \n    getUnlayeredWorkers: function() {\n      var unlayered_workers = [];\n      \n      for (var i = 0; i < this.workers.length; i++) {\n        var worker = this.workers[i];\n        if (!worker.layered) {\n          unlayered_workers.push(worker);\n        }\n      }\n      \n      return unlayered_workers;\n    },\n    \n    incomingMessage: function(name, body) {\n      if (name == "changeLayer") {\n        var worker = this.findWorkerById(body.worker_id);\n        var layer = body.layer;\n        this.changeLayer(worker, layer);\n        return this.workers;\n      }\n    },\n    \n    layeredWorkerCount: function() {\n      var count = 0;\n      for (var i = 0; i < this.workers.length; i++) {\n        var worker = this.workers[i];\n        if (worker.layered) {\n          count++;\n        }\n      }\n      return count;\n    },\n    \n    changeLayer: function(swap_worker, layer) {\n      \n      var layered_workers = this.getLayeredWorkers();\n      var unlayered_workers = this.getUnlayeredWorkers();\n      \n      var new_worker_index = layer;\n      var current_worker_index = layered_workers.indexOf(swap_worker);\n      layered_workers.splice(current_worker_index, 1);\n      layered_workers.splice(new_worker_index, 0, swap_worker);\n      \n      this.workers = layered_workers.concat(unlayered_workers);\n      \n    }\n\n  };\n  \n  var AnimationWorker = function(options) {\n    this._initAnimationWorker(options);\n  };\n\n  AnimationWorker.prototype = {\n\n    _initAnimationWorker: function(options) {\n      \n      this.superParent(options);\n\n      this.context = Animation.context;\n\n    },\n\n    createAnimationInput: function(options) {\n      var input = {\n        name: options.name,\n        default_value: options.default_value\n      };\n      this.inputAttributes[input.name] = input.default_value;\n\n      return input;\n    },\n\n    createAnimationOutput: function(options) {\n      var output = {\n        name: options.name,\n        default_value: options.default_value\n      };\n      this.outputAttributes[output.name] = output.default_value;\n\n      return output;\n    }//,\n    \n    // addEventListener: function(event_name, callback) {\n    //   this.events[event_name] = function(event) {\n    //     callback(event);\n    //   };\n    // },\n    // \n    // triggerEvent: function(event) {\n    //   event.node_id = this.id;\n    //   this.runtime_manager.triggerEvent(event);\n    // }\n\n  };\n\n  registerRuntime({\n    name: "Animation",\n    runtime: Animation,\n    worker: AnimationWorker\n  });\n  \n  //aaa = Animation;\n  \n});\n\nwindow.requestAnimFrame = (function(callback) {\n  return window.requestAnimationFrame || \n  window.webkitRequestAnimationFrame || \n  window.mozRequestAnimationFrame || \n  window.oRequestAnimationFrame || \n  window.msRequestAnimationFrame ||\n  function(callback) {\n    window.setTimeout(function() {\n      var timestamp = Date.now();\n      callback(timestamp);\n    }, 1000 / 60);\n  };\n})();\n//@ sourceURL=/runtimes/animation.js'),eval('define(\'runtimes/audio\',[\'runtimes/register_runtime\',\'lib/extend\',\'runtimes/event\'], function(registerRuntime, extend) {\n  \n  var Audio = {\n\n    name: "Audio",\n    color: "blue",\n    icon_src: "images/audio.png",\n\n    display: true,\n    \n    workerTypes: {}, // make this an array\n    workers: {}, // make this an array\n    \n    init: function(options) {\n      try {\n        this.context = new webkitAudioContext();\n      }\n      catch (e) {\n        this.context = null;\n      }\n    },\n\n    registerWorker: function(worker, type) {\n      extend(worker, AudioWorker);\n      this.workerTypes[type] = worker;\n      this.eventRuntime.registerWorker(worker, type);\n    },\n\n    clearAll: function() {\n      for (var w in this.workers) {\n        delete(this.workers[w]);\n      }\n      this.workers = {};\n    },\n\n    create: function(node) {\n      var worker;\n      if (this.context) {\n        var workerType = this.workerTypes[node.type];\n        worker = new workerType({\n          id: node.id\n        });\n        this.workers[worker.id] = worker;\n      }\n      else {\n        worker = new this.eventWorker({\n          id: node.id\n        });\n        this.workers[worker.id] = worker;\n      }\n\n    },\n\n    remove: function(worker) {\n      delete(this.workers[worker.id]);\n    },\n\n    connect: function(edge) {\n      if (!this.context) {\n        return;\n      }\n      var destination = this.workers[edge.destination_id];\n      var source = this.workers[edge.source_id];\n\n      var input_name = edge.input_name;\n      var input = destination.audioInputs[input_name];\n\n      var output_name = edge.output_name;\n      var output = source.audioOutputs[output_name];\n\n      output.connect_point.connect(input.connect_point);\n\n    },\n\n    disconnect: function(edge) {\n      if (!this.context) {\n        return;\n      }\n      var destination = this.workers[edge.destination_id];\n      var source = this.workers[edge.source_id];\n\n      var input_name = edge.input_name;\n      var input = destination.audioInputs[input_name];\n\n      var output_name = edge.output_name;\n      var output = source.audioOutputs[output_name];\n\n      output.connect_point.disconnect(input.connect_point);\n\n    },\n\n    // START STUB\n    setWorkerAttribute: function(options) {\n      var worker = this.workers[options.worker_id];\n      var set_function_name = "set" + options.input_name[0].toUpperCase() + options.input_name.slice(1, options.input_name.length);\n      if (worker[set_function_name]) {\n        worker[set_function_name](options.value);\n      }\n      worker.inputAttributes[options.input_name] = options.value;\n    },\n    \n    getWorkerAttribute: function(options) {\n      var worker = this.workers[options.worker_id];\n      return worker.inputAttributes[options.input_name];\n    },\n\n    getWorkerAttributes: function(options) {\n      var worker = this.workers[options.worker_id];\n      var return_object = {\n        worker_id: worker.id,\n        value: {} // STUB\n      };\n      return return_object;\n    },\n    // END STUB\n\n    allWorkersAttributes: function() {\n      var workers = [];\n      for (var i in this.workers) {\n        var worker = this.workers[i];\n        if (worker.inputAttributes && worker.outputAttributes) {\n          var worker_attributes = {\n            id: worker.id,\n            inputAttributes: this.sanitizeAttributes(worker.inputAttributes),\n            outputAttributes: this.sanitizeAttributes(worker.outputAttributes)\n          };\n          workers.push(worker_attributes);\n        }\n      }\n      return workers;\n    },\n\n    sanitizeAttributes: function(attributes) {\n      var sanitized_attributes = {};\n      for (var a in attributes) {\n        var attribute = attributes[a];\n        if (typeof(attribute) == "string" || typeof(attribute) == "number") {\n          sanitized_attributes[a] = attribute;\n        }\n      }\n      return sanitized_attributes;\n    },\n\n    parse: function(workers_attributes) {\n      \n      var i;\n      for (i=0; i < workers_attributes.length; i++) {\n        var worker_attributes = workers_attributes[i];\n        var worker = this.workers[worker_attributes.id];\n        worker.inputAttributes = worker_attributes.inputAttributes;\n        worker.outputAttributes = worker_attributes.outputAttributes;\n        \n        var function_name;\n        for (i in worker.inputAttributes) {\n          function_name = "set" + i[0].toUpperCase() + i.slice(1,i.length);\n          if (worker[function_name]) {\n            worker[function_name](worker.inputAttributes[i]);\n          }\n        }\n\n        for (i in worker.outputAttributes) {\n          function_name = "set" + i[0].toUpperCase() + i.slice(1,i.length);\n          if (worker[function_name]) {\n            worker[function_name](worker.outputAttributes[i]);\n          }\n        }\n\n      }\n    }\n\n  };\n  \n  var AudioWorker = function(options) {\n    this._initAudioWorker(options);\n  };\n\n  AudioWorker.prototype = {\n\n    _initAudioWorker: function(options) {\n\n      this.superParent(options);\n\n      this.context = Audio.context;\n\n      this.audioInputs = {};\n      this.audioOutputs = {};\n\n    },\n\n    createAudioInput: function(options) {\n      var input = {\n        connect_point: options.connect_point,\n        name: options.name\n      };\n      this.audioInputs[input.name] = input;\n      return input;\n    },\n\n    createAudioOutput: function(options) {\n      var output = {\n        connect_point: options.connect_point,\n        name: options.name\n      };\n      this.audioOutputs[output.name] = output;\n      return output;\n    }\n\n  };\n\n  registerRuntime({\n    name: "Audio",\n    runtime: Audio,\n    worker: AudioWorker\n  });\n  \n});\n\n\n//@ sourceURL=/runtimes/audio.js'),eval('/*global define:false */\n/*global XMLHttpRequest:false */\n/*\n\n  AudioFile\n  -----------------\n\n*/\n\ndefine(\'nodes/audio_file\',[\'register_node\'], function(registerNode) {\n  \n  // Node\n  // ====\n  var AudioFile = function(options) {\n    this._initAudioFileOutput(options);\n  };\n  AudioFile.prototype = {\n  \n    _initAudioFileOutput: function(options) {\n    \n      this.callSuper(options);\n    \n      this.createIO();\n    \n    },\n  \n    createIO: function() {\n    \n      this.createInput({\n        name: "trigger_in"\n      });\n      \n      this.createOutput({\n        name: "audio_out",\n        runtime: "Audio"\n      });\n    \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var AudioFileWorker = function(options) {\n    this._initAudioFileWorker(options);\n  };\n  AudioFileWorker.prototype = {\n  \n    _initAudioFileWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n      \n      this.createEventListeners();\n      \n    },\n    \n    createIO: function() {\n      \n      var that = this;\n      this.createEventInput({\n        name: "trigger_in",\n        connect_point: function(event) {\n          that.processIncomingEvent(event);\n        }\n      });\n      \n      this.outputNode = this.context.createGainNode();\n    \n      this.createAudioOutput({\n        name: "audio_out",\n        connect_point: this.outputNode\n      });\n      \n    },\n    \n    processIncomingEvent: function(event) {\n      \n      this.play(0);\n\n      this.triggerEvent({\n        name: "trigger_event",\n        event: event\n      });\n      \n    },\n    \n    createEventListeners: function() {\n      \n      var that = this;\n      \n      this.addEventListener("play", function() {   \n        that.play(0);\n      });\n      \n    },\n    \n    setBuffer: function(arraybuffer) {\n      var that = this;\n      this.context.decodeAudioData(arraybuffer, function(buffer) {\n        that.buffer = buffer;\n      }, null);\n      \n    },\n    \n    setUrl: function(url) {\n      this.setBufferUrl(url);\n    },\n\n    setBufferUrl: function(url) {\n      var request = new XMLHttpRequest();\n      request.open(\'GET\', url, true);\n      request.responseType = \'arraybuffer\';\n\n      var that = this;\n      request.onload = function() {\n        that.context.decodeAudioData(request.response, function(buffer) {\n          that.buffer = buffer;\n        }, null);\n      };\n      request.send();\n      \n    },\n\n    play: function(time) {\n      \n      var source = this.context.createBufferSource();\n      source.loop = this.loop;\n      source.playbackRate.setValueAtTime(this.playbackRate, 0);\n      source.buffer = this.buffer;\n      source.connect(this.outputNode);\n      source.noteOn(time);\n      \n    }\n    \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "audio file",\n    runtime: "Audio",\n    node: AudioFile,\n    worker: AudioFileWorker\n  });\n  \n});\n//@ sourceURL=/nodes/audio_file.js'),eval('/*global define:false */\n/*global navigator:false */\n/*\n\n  AudioInput Node\n  ----------------\n\n*/\n\ndefine(\'nodes/audio_input\',[\'register_node\'], function(registerNode) {\n  \n  // Node\n  // ====\n  var AudioInput = function(options) {\n    this._initAudioInput(options);\n  };\n  AudioInput.prototype = {\n  \n    _initAudioInput: function(options) {\n    \n      options.fill = "#FFFFFF";\n      options.showIOLabelsWhenSelected = false;\n    \n      this.callSuper(options);\n    \n      this.createIO();\n    \n    },\n  \n    createIO: function() {\n    \n      this.createOutput({\n        y_offset: 20,\n        name: "audio_out",\n        runtime: "Audio"\n      });\n    \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var AudioInputWorker = function(options) {\n    this._initAudioInputWorker(options);\n  };\n  AudioInputWorker.prototype = {\n  \n    _initAudioInputWorker: function(options) {\n    \n      this.callSuper(options);\n\n      this.outputNode = this.context.createGainNode();\n      this.outputNode.gain.setValueAtTime(1.0, this.context.currentTime);\n    \n      this.createAudioOutput({\n        name: "audio_out",\n        connect_point: this.outputNode\n      });\n      \n      this.initStream();\n\n    },\n    \n    initStream: function() {\n\n      if (!navigator.webkitGetUserMedia) {\n        return;\n      }\n\n      var that = this;\n      navigator.webkitGetUserMedia({audio:true}, function(stream) {\n        that.input = that.context.createMediaStreamSource(stream);\n        that.input.connect(that.outputNode);\n      }, null);\n\n    }\n    \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "audio input",\n    alias: "ai",\n    runtime: "Audio",\n    node: AudioInput,\n    worker: AudioInputWorker\n  });\n  \n});\n//@ sourceURL=/nodes/audio_input.js'),eval('/*global define:false */\n/*\n\n  AudioOutput Node\n  ----------------\n\n*/\n\ndefine(\'nodes/audio_output\',[\'register_node\'], function(registerNode) {\n  \n  // Node\n  // ====\n  var AudioOutput = function(options) {\n    this._initAudioOutput(options);\n  };\n  AudioOutput.prototype = {\n  \n    _initAudioOutput: function(options) {\n    \n      options.fill = "#FFFFFF";\n      options.showIOLabelsWhenSelected = false;\n    \n      this.callSuper(options);\n    \n      this.createIO();\n    \n    },\n  \n    createIO: function() {\n    \n      this.createInput({\n        y_offset: 20,\n        name: "audio_in",\n        runtime: "Audio"\n      });\n    \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var AudioOutputWorker = function(options) {\n    this._initAudioOutputWorker(options);\n  };\n  AudioOutputWorker.prototype = {\n  \n    _initAudioOutputWorker: function(options) {\n    \n      this.callSuper(options);\n\n      this.inputNode = this.context.createGainNode();\n      this.inputNode.gain.setValueAtTime(1.0, this.context.currentTime);\n    \n      this.inputNode.connect(this.context.destination);\n    \n      this.createAudioInput({\n        name: "audio_in",\n        connect_point: this.inputNode\n      });\n\n    }\n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "audio output",\n    alias: "ao",\n    runtime: "Audio",\n    node: AudioOutput,\n    worker: AudioOutputWorker\n  });\n  \n});\n//@ sourceURL=/nodes/audio_output.js'),eval('/*global define:false */\n/*global setTimeout:false */\n/*\n\n  Button\n  ------\n\n*/\n\ndefine(\'nodes/button\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var Button = function(options) {\n    this._initButton(options);\n  };\n  Button.prototype = {\n  \n    _initButton: function(options) {\n      \n      options.width = 70;\n      options.height = 70;\n      options.noTitle = true;\n      this.callSuper(options);\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n      \n      this.createInput({\n        y_offset: 35,\n        name: "midi_in",\n        runtime: "MIDI"\n      });\n      \n      this.createOutput({\n        y_offset: 35,\n        name: "trigger_out"\n      });\n      \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var ButtonWorker = function(options) {\n    this._initButtonWorker(options);\n  };\n  ButtonWorker.prototype = { \n  \n    _initButtonWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.midiNoteTrigger = null;\n      \n      this.createIO();\n      this.createEventListeners();\n    \n    },\n    \n    createIO: function() {\n      \n      var that = this;\n      \n      this.createMIDIInput({\n        name: "midi_in",\n        connect_point: function(event) {\n          that.processIncomingMIDI(event);\n        }\n      });\n      \n      this.createEventOutput({\n        name: "trigger_out"\n      });\n    },\n    \n    createEventListeners: function() {\n      \n      var that = this;\n      \n      this.addEventListener("trigger_event", function(event) {\n        \n        this.trigger({\n          source: that,\n          output_name: "trigger_out",\n          event: event\n        });\n        \n      });\n      \n      this.addEventListener("learn_mode", function(event) {\n        \n        that.learnMode = event;\n        \n      });\n      \n    },\n    \n    processIncomingMIDI: function(event) {\n      \n      if (this.learnMode) {\n        this.midiNoteTrigger = event.note;\n        this.learnMode = false;\n        this.triggerEvent({\n          name: "disable_learn_mode",\n          event: event\n        });\n      }\n      else {\n        if (this.midiNoteTrigger == event.note) {\n          \n          this.triggerEvent({\n            name: "trigger_midi_start",\n            event: event\n          });\n          \n          this.trigger({\n            source: this,\n            output_name: "trigger_out",\n            event: true\n          });\n          \n          var that = this;\n          setTimeout(function() {\n            that.triggerEvent({\n              name: "trigger_midi_end",\n              event: true\n            });\n          }, 100);\n          \n        }\n      }\n      \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "button",\n    alias: "b",\n    runtime: "MIDI",\n    node: Button,\n    worker: ButtonWorker\n  });\n  \n});\n//@ sourceURL=/nodes/button.js'),eval('/*global define:false */\n/*\n\n  Delay\n  -----------------\n\n*/\n\ndefine(\'nodes/delay\',[\'register_node\'], function(registerNode) {\n  \n  // Node\n  // ====\n  var Delay = function(options) {\n    this._initDelayOutput(options);\n  };\n  Delay.prototype = {\n  \n    _initDelayOutput: function(options) {\n    \n      options.width = 55;\n      options.height = 55;\n    \n      this.callSuper(options);\n    \n      this.createIO();\n    \n    },\n  \n    createIO: function() {\n    \n      this.createInput({\n        y_offset: 27.5,\n        name: "audio_in",\n        runtime: "Audio"\n      });\n      \n      this.createOutput({\n        y_offset: 27.5,\n        name: "audio_out",\n        runtime: "Audio"\n      });\n    \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var DelayWorker = function(options) {\n    this._initDelayWorker(options);\n  };\n  DelayWorker.prototype = {\n  \n    _initDelayWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n\n      this.createAudioGraph();\n\n    },\n    \n    createIO: function() {\n      \n      this.inputNode = this.context.createGainNode();\n    \n      this.createAudioInput({\n        name: "audio_in",\n        connect_point: this.inputNode\n      });\n      \n      this.outputNode = this.context.createGainNode();\n    \n      this.createAudioOutput({\n        name: "audio_out",\n        connect_point: this.outputNode\n      });\n      \n    },\n    \n    createAudioGraph: function() {\n      \n      this.delay = this.context.createDelayNode();\n      this.delay.delayTime.value = 0.5;\n\n      this.feedbackGain = this.context.createGainNode();\n      this.feedbackGain.gain.value = 0.2;\n\n      this.inputNode.connect(this.delay);\n      this.feedbackGain.connect(this.delay);\n      this.delay.connect(this.feedbackGain);\n      this.feedbackGain.connect(this.outputNode);\n      \n    }\n    \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "delay",\n    runtime: "Audio",\n    node: Delay,\n    worker: DelayWorker\n  });\n  \n});\n//@ sourceURL=/nodes/delay.js'),eval('/*global define:false */\n/*\n\n  EventToAnimation\n  -----------------\n\n*/\n\ndefine(\'nodes/event_to_animation\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var EventToAnimation = function(options) {\n    this._initEventToAnimation(options);\n  };\n  EventToAnimation.prototype = {\n  \n    _initEventToAnimation: function(options) {\n      \n      options.width = 20;\n      options.height = 20;\n      options.noTitle = true;\n      options.showIOLabelsWhenSelected = false;\n      this.callSuper(options);\n      \n      this.value = 0;\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n      \n      this.createInput({\n        y_offset: 10,\n        name: "event_in"\n      });\n      \n      this.createOutput({\n        y_offset: 10,\n        name: "animation_out",\n        default_value: 0,\n        runtime: "Animation"\n      });\n      \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var EventToAnimationWorker = function(options) {\n    this._initEventToAnimationWorker(options);\n  };\n  EventToAnimationWorker.prototype = { \n  \n    _initEventToAnimationWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n      \n      var that = this;\n      \n      this.createEventInput({\n        name: "event_in",\n        connect_point: function(event) {\n          that.processIncomingNumber(event);\n        }\n      });\n      \n      this.createEventOutput({\n        name: "animation_out"\n      });\n    },\n    \n    processIncomingNumber: function(event) {\n      \n      this.value = parseFloat(event);\n      \n    },\n    \n    runLoop: function() {\n      this.outputAttributes.animation_out = this.value;\n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "event to animation",\n    alias: "etoa",\n    runtime: "Animation",\n    node: EventToAnimation,\n    worker: EventToAnimationWorker\n  });\n  \n});\n//@ sourceURL=/nodes/event_to_animation.js'),eval('/*global define:false */\n/*\n\n  GateSwitch Node\n  ---------------\n\n*/\n\ndefine(\'nodes/gate_switch\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var GateSwitch = function(options) {\n    this._initGateSwitch(options);\n  };\n  GateSwitch.prototype = {\n  \n    _initGateSwitch: function(options) {\n    \n      options.height = 80;\n      this.callSuper(options);\n    \n      this.createIO();\n\n    },\n\n    createIO: function() {\n      \n      this.createInput({\n        name: "value 1",\n        runtime: "Animation"\n      });\n      \n      this.createInput({\n        name: "value 2",\n        runtime: "Animation"\n      });\n      \n      this.createInput({\n        name: "gate",\n        runtime: "Animation"\n      });\n      \n      this.createOutput({\n        name: "value out",\n        runtime: "Animation"\n      });\n      \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var GateSwitchWorker = function(options) {\n    this._initGateSwitchWorker(options);\n  };\n  GateSwitchWorker.prototype = {\n  \n    _initGateSwitchWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n    \n      this.createAnimationInput({\n        name: "value 1"\n      });\n      \n      this.createAnimationInput({\n        name: "value 2"\n      });\n      \n      this.createAnimationInput({\n        name: "gate",\n        default_value: true\n      });\n      \n      this.createAnimationOutput({\n        name: "value out"\n      });\n      \n    },\n  \n    runLoop: function() {\n      \n      //console.log(this.inputAttributes["gate"]);\n      \n      if (this.inputAttributes.gate === true) {\n        this.outputAttributes["value out"] = this.inputAttributes["value 1"];\n      }\n      else {\n        this.outputAttributes["value out"] = this.inputAttributes["value 2"];\n      }\n    \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "gate switch",\n    runtime: "Animation",\n    node: GateSwitch,\n    worker: GateSwitchWorker\n  });\n  \n});\n//@ sourceURL=/nodes/gate_switch.js'),eval('/*global define:false */\n/*\n\n  GrayscaleFilter Node\n  ---------------\n\n*/\n\ndefine(\'nodes/grayscale\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var GrayscaleFilter = function(options) {\n    this._initGrayscaleFilter(options);\n  };\n  GrayscaleFilter.prototype = {\n  \n    _initGrayscaleFilter: function(options) {\n    \n      options.height = 80;\n      this.callSuper(options);\n    \n      this.createIO();\n\n    },\n\n    createIO: function() {\n      \n      this.createInput({\n        name: "image",\n        runtime: "Animation"\n      });\n      \n      this.createOutput({\n        name: "image",\n        runtime: "Animation"\n      });\n      \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var GrayscaleFilterWorker = function(options) {\n    this._initGrayscaleFilterWorker(options);\n  };\n  GrayscaleFilterWorker.prototype = {\n  \n    _initGrayscaleFilterWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n    \n      this.createAnimationInput({\n        name: "image"\n      });\n      \n      this.createAnimationOutput({\n        name: "image"\n      });\n      \n    },\n  \n    runLoop: function() {\n      \n      if (this.previousImage == this.inputAttributes.image) {\n        return;\n      }\n      \n      if (this.inputAttributes.image && this.inputAttributes.image.data) {\n        \n        this.previousImage = this.inputAttributes.image;\n        \n        var image_data = this.context.createImageData(this.inputAttributes.image.width, this.inputAttributes.image.height);\n        image_data.data.set(this.inputAttributes.image.data);\n\n        var data = image_data.data;\n\n        for (var i=0; i<data.length; i+=4) {\n          var r = data[i];\n          var g = data[i+1];\n          var b = data[i+2];\n          // CIE luminance for the RGB\n          // The human eye is bad at seeing red and blue, so we de-emphasize them.\n          var v = 0.2126*r + 0.7152*g + 0.0722*b;\n          data[i] = data[i+1] = data[i+2] = v;\n        }\n\n        this.outputAttributes.image = image_data;\n      \n      }\n      \n\n    \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "grayscale",\n    runtime: "Animation",\n    node: GrayscaleFilter,\n    worker: GrayscaleFilterWorker\n  });\n  \n});\n//@ sourceURL=/nodes/grayscale.js'),eval('/*global define:false */\n/*\n\n  HSLA Color Node\n  ---------------\n\n*/\n\ndefine(\'nodes/hsla\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var HSLA = function(options) {\n    this._initHSLA(options);\n  };\n  HSLA.prototype = {\n  \n    _initHSLA: function(options) {\n    \n      options.fill = "#FFFFFF";\n      options.height = 90;\n      this.callSuper(options);\n    \n      this.createIO();\n\n    },\n\n    createIO: function() {\n      \n      this.createInput({\n        name: "hue", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "saturation", \n        runtime: "Animation"\n      });\n      \n      this.createInput({\n        name: "lightness", \n        runtime: "Animation"\n      });\n      \n      this.createInput({\n        name: "alpha", \n        runtime: "Animation"\n      });\n      \n      this.createOutput({\n        name: "color",\n        runtime: "Animation"\n      });\n    }\n  \n  };\n\n  // Worker\n  // ======\n  var HSLAWorker = function(options) {\n    this._initHSLAWorker(options);\n  };\n  HSLAWorker.prototype = {\n  \n    _initHSLAWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n      this.createAnimationInput({\n        name: "hue",\n        default_value: 0.0\n      });\n    \n      this.createAnimationInput({\n        name: "saturation",\n        default_value: 1.0\n      });\n    \n      this.createAnimationInput({\n        name: "lightness",\n        default_value: 0.5\n      });\n      \n      this.createAnimationInput({\n        name: "alpha",\n        default_value: 1.0\n      });\n    \n      this.createAnimationOutput({\n        name: "color"\n      });\n    },\n  \n    runLoop: function() {\n    \n      var hue = parseFloat(this.inputAttributes.hue) || 0;\n      var saturation = parseFloat(this.inputAttributes.saturation) || 1;\n      var lightness = parseFloat(this.inputAttributes.lightness) || 0.5;\n      var alpha = parseFloat(this.inputAttributes.alpha) || 1.0;\n    \n      var color = "hsla(" + hue*360 + "," + saturation*100 + "%, " + lightness*100 + "%, " + alpha + ")";\n    \n      this.outputAttributes.color = color;\n    \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "hsla",\n    runtime: "Animation",\n    node: HSLA,\n    worker: HSLAWorker\n  });\n  \n});\n//@ sourceURL=/nodes/hsla.js'),eval('/*global define:false */\n/*\n\n  HueAdjust Node\n  ---------------\n\n*/\n\ndefine(\'nodes/hue_adjust\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var HueAdjust = function(options) {\n    this._initHueAdjust(options);\n  };\n  HueAdjust.prototype = {\n  \n    _initHueAdjust: function(options) {\n    \n      options.height = 80;\n      this.callSuper(options);\n    \n      this.createIO();\n\n    },\n\n    createIO: function() {\n      \n      this.createInput({\n        name: "image",\n        runtime: "Animation"\n      });\n      \n      this.createInput({\n        name: "angle",\n        runtime: "Animation"\n      });\n      \n      this.createOutput({\n        name: "image",\n        runtime: "Animation"\n      });\n      \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var HueAdjustWorker = function(options) {\n    this._initHueAdjustWorker(options);\n  };\n  HueAdjustWorker.prototype = {\n  \n    _initHueAdjustWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n      \n      this.createAnimationInput({\n        name: "image"\n      });\n      \n      this.createAnimationInput({\n        name: "angle",\n        default_value: 0\n      });\n      \n      this.createAnimationOutput({\n        name: "image"\n      });\n      \n    },\n    \n    // http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n    \n    rgbToHsl: function(r, g, b) {\n        r /= 255; g /= 255; b /= 255;\n        var max = Math.max(r, g, b), min = Math.min(r, g, b);\n        var h, s, l = (max + min) / 2;\n\n        if(max == min){\n            h = s = 0; // achromatic\n        }else{\n            var d = max - min;\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            switch(max){\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2; break;\n                case b: h = (r - g) / d + 4; break;\n            }\n            h /= 6;\n        }\n\n        return [h, s, l];\n    },\n    \n    hue2rgb: function(p, q, t) {\n      if(t < 0) t += 1;\n      if(t > 1) t -= 1;\n      if(t < 1/6) return p + (q - p) * 6 * t;\n      if(t < 1/2) return q;\n      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n      return p;\n    },\n    \n    hslToRgb: function(h, s, l) {\n        var r, g, b;\n\n        if (s === 0){\n            r = g = b = l; // achromatic\n        }\n        else {\n          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n          var p = 2 * l - q;\n          r = this.hue2rgb(p, q, h + 1/3);\n          g = this.hue2rgb(p, q, h);\n          b = this.hue2rgb(p, q, h - 1/3);\n        }\n\n        return [r * 255, g * 255, b * 255];\n    },\n  \n    runLoop: function() {\n      \n      if (this.previousAngle == this.inputAttributes.angle && this.previousImage == this.inputAttributes.image) {\n        return;\n      }\n      \n      if (this.inputAttributes.image && this.inputAttributes.image.data) {\n        \n        this.previousImage = this.inputAttributes.image;\n        this.previousAngle = this.inputAttributes.angle;\n      \n        var image_data = this.context.createImageData(this.inputAttributes.image.width, this.inputAttributes.image.height);\n        image_data.data.set(this.inputAttributes.image.data);\n\n\n\n        var data = image_data.data;\n        \n        // optimize with: http://jsperf.com/canvas-pixel-manipulation/30\n        // var buf = new ArrayBuffer(image_data.data.length);\n        // var buf8 = new Uint8ClampedArray(buf);\n        // var data32 = new Uint32Array(buf);\n        \n        // and check out: http://jsperf.com/typed-arrays-for-pixel-manipulation\n\n        for (var i=0; i<data.length; i+=4) {\n          \n          var r = data[i];\n          var g = data[i+1];\n          var b = data[i+2];\n          \n          var current_hsl = this.rgbToHsl(r, g, b);\n          var current_hue = current_hsl[0];\n          \n          var new_hue = current_hue + (this.inputAttributes.angle/360.0);\n          \n          var rgb = this.hslToRgb(new_hue, current_hsl[1], current_hsl[2]);\n          \n          var new_r = rgb[0];\n          var new_g = rgb[1];\n          var new_b = rgb[2];\n          \n          data[i] = new_r;\n          data[i+1] = new_g;\n          data[i+2] = new_b;\n        }\n        \n        this.outputAttributes.image = image_data;\n      \n      }\n    \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "hue adjust",\n    runtime: "Animation",\n    node: HueAdjust,\n    worker: HueAdjustWorker\n  });\n  \n});\n//@ sourceURL=/nodes/hue_adjust.js'),eval('/*global define:false */\n/*global $:false */\n/*global document:false */\n/*global Image:false */\n/*\n\n  ImageFile\n  -----------------\n\n*/\n\ndefine(\'nodes/image_file\',[\'register_node\'], function(registerNode) {\n  \n  // Node\n  // ====\n  var ImageFile = function(options) {\n    this._initImageFileOutput(options);\n  };\n  ImageFile.prototype = {\n  \n    _initImageFileOutput: function(options) {\n    \n      this.callSuper(options);\n    \n      this.createIO();\n      \n      this.createViewAndEventListeners();\n    \n    },\n  \n    createIO: function() {\n    \n      // this.createInput({\n      //   name: "url",\n      //   runtime: "Animation"\n      // });\n      \n      this.createOutput({\n        name: "image",\n        runtime: "Animation"\n      });\n    \n    },\n    \n    createViewAndEventListeners: function() {\n      \n      var that = this;\n      \n      var view = new ImageFileView({\n        node: this\n      });\n      \n      this.addEventListener("image_url", function(url) {\n        \n        that.$title.css({\n          color: "white"\n        });\n        \n        view.$img[0].src = url;\n        \n        view.$img[0].onload = function() {\n          that.editor.emit("imageLoaded");\n\n          \n          var display_width = that.$display.width();\n          \n          var width = view.$img[0].width;\n          \n          if (width < display_width) {\n\n            view.$img.css({\n              width: display_width\n            });\n            \n          }\n          else {\n            \n          }\n          \n          var height = view.$img[0].height;\n          \n          that.$display.css({\n            width: display_width,\n            height: height,\n            "text-shadow": "0px 0px 6px rgba(0,0,0,0.8)",\n            \'background-color\': \'black\'\n          });\n          \n          that.recomputeOutline();\n          that.editor.currentPatch.redrawEdges();\n          that.callDragEvents();\n          \n        };\n        \n      });\n\n      \n    }\n  \n  };\n  \n  // View\n  // ====\n  var ImageFileView = function(options) {\n    this._initImageFileView(options);\n  };\n  ImageFileView.prototype = {\n  \n    _initImageFileView: function(options) {\n    \n      this.callSuper(options);\n      \n      this.$img = $("<img />");\n      this.$img.css({\n        width: "100%"\n      });\n      \n      this.$img.mousedown(function(event) {\n        event.preventDefault();\n      });\n      \n      this.appendView(this.$img[0]);\n      \n    }\n    \n  };\n\n  // Worker\n  // ======\n  var ImageFileWorker = function(options) {\n    this._initImageFileWorker(options);\n  };\n  ImageFileWorker.prototype = {\n  \n    _initImageFileWorker: function(options) {\n      \n      this.imageCanvas = document.createElement(\'canvas\');\n      this.imageContext = this.imageCanvas.getContext(\'2d\');\n    \n      this.callSuper(options);\n      \n      this.createIO();\n      \n      this.createEventListeners();\n      \n    },\n    \n    createIO: function() {\n      \n      this.createAnimationInput({\n        name: "url",\n        default_value: ""\n      });\n    \n      this.createAnimationOutput({\n        name: "image",\n        default_value: null\n      });\n      \n    },\n    \n    createEventListeners: function() {\n      \n      var worker = this;\n      \n      this.addEventListener("update_width", function(event) {\n        \n        worker.imageLoaded = false;\n        \n        worker.maxWidth = ($(".animation-viewer").width() / 2) * event.width;\n        worker.previousUrl = false;\n        \n        if (worker.$image) {\n          worker.$image.remove();\n          worker.$image = null;\n        }\n        \n        if (worker.image) {\n          worker.image = null;\n        }\n        \n      });\n      \n    },\n\n    runLoop: function() {\n      if (!this.previousUrl) {\n        this.previousUrl = null;\n      }\n      if (this.previousUrl != this.inputAttributes.url) {\n        \n        this.imageLoaded = false;\n        this.previousUrl = this.inputAttributes.url;\n        this.image = new Image();\n        this.image.crossOrigin = \'\';\n        \n        var image_src = this.inputAttributes.url;\n        \n        // imgix doesn\'t support GIFs just yet\n        if (this.inputAttributes.url.indexOf(".gif") != -1) {\n          image_src = image_src + "?cache_buster=" + parseInt(Math.random()*10000000000, 10).toString();\n        }\n        \n        else {\n          \n          // use imgix\n          if (image_src.indexOf("https://graph-editor-upload.s3.amazonaws.com") != -1) {\n            var s3_file_url = image_src;\n            image_src = s3_file_url.replace("https://graph-editor-upload.s3.amazonaws.com","http://graph-editor-upload.imgix.net");\n          }\n\n          \n          // http://stackoverflow.com/questions/12648809/cors-policy-on-cached-image\n          // WebKit has an issue with cached images and CORS...\n          if (image_src.indexOf("?") != -1) {\n            image_src = image_src + "&cache_buster=" + parseInt(Math.random()*10000000000, 10).toString();\n          }\n          else {\n            image_src = image_src + "?cache_buster=" + parseInt(Math.random()*10000000000, 10).toString();\n          }\n\n          // fancy autoresizing of images using imgix for performance gains\n          if (image_src.indexOf("http://graph-editor-upload.imgix.net") != -1) {\n            var max_width;\n            \n            if (this.maxWidth) {\n              max_width = this.maxWidth;\n            }\n            else {\n              max_width = $(".animation-viewer").width();\n            }\n            \n            image_src = image_src + "&w=" + max_width/2;\n          }          \n          \n        }\n        \n        \n        if ($.browser.msie && (image_src.indexOf("graph-editor-upload") != -1)) {\n          image_src = \'/media/proxy/\' + encodeURIComponent(image_src);\n        }\n        \n        this.image.src = image_src;\n        \n        // by appending the image to the document, if it\'s an animated gif, it\'ll start playing\n        this.$image = $(this.image);\n        this.$image.appendTo($(document.body));\n        this.$image.css({\n          position: "fixed",\n          //left: "-5000px" // this works everywhere but on current  - Chrome 23.0.1271.101 FIX\n          right: 0, \n          bottom: 0,\n          opacity: 0.0, // so instead we just set 0 opacity - Chrome 23.0.1271.101 FIX\n          \'z-index\': 1000000\n        });\n        \n        var that = this;\n        this.image.onload = function() {\n          that.triggerEvent({\n            name: "image_url",\n            event: image_src,\n            force: true\n          });\n          var width = that.image.width;\n          var height = that.image.height;\n          \n          that.$image.css({\n            right: -(width - 1), // and then move it almost completely away so it doesn\'t obtstruct the view - Chrome 23.0.1271.101 FIX\n            bottom: -(height - 1)\n          });\n          \n          that.imageCanvas.width = width;\n          that.imageCanvas.height = height;\n          that.imageContext.width = width;\n          that.imageContext.height = height;\n\n          that.imageContext.drawImage(that.image, 0, 0, width, height);\n          \n          var image_data;\n          try {\n            image_data = that.imageContext.getImageData(0, 0, width, height); //yu error?\n          } catch (e) {}\n          \n          that.outputAttributes.image = image_data;\n          that.imageLoaded = true;\n\n        };\n        \n        this.outputAttributes.image = [];\n      }\n      else {\n        if (this.imageLoaded && this.image.src.indexOf(".gif") != -1) {\n          var width = this.image.width;\n          var height = this.image.height;\n          this.imageContext.clearRect(0,0,width, height);\n          this.imageContext.drawImage(this.image, 0, 0, width, height);\n          var image_data = this.imageContext.getImageData(0, 0, width, height);\n          this.outputAttributes.image = image_data;\n        }\n\n      }\n      \n    }\n    \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "image file",\n    runtime: "Animation",\n    node: ImageFile,\n    view: ImageFileView,\n    worker: ImageFileWorker\n  });\n  \n});\n//@ sourceURL=/nodes/image_file.js'),eval('/*global define:false */\n/*global $:false */\n/*\n\n  LFO Node\n  --------\n\n*/\n\ndefine(\'nodes/lfo\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var LFO = function(options) {\n    this._initLFO(options);\n  };\n  LFO.prototype = {\n  \n    _initLFO: function(options) {\n    \n      options.fill = "#FFFFFF";\n      options.height = 110;\n      this.callSuper(options);\n    \n      this.createIO();\n      \n      this.createViewAndEventListeners();\n\n    },\n\n    createIO: function() {\n      \n      this.createInput({\n        name: "waveform", \n        runtime: "Animation",\n        select_options_index: ["sine", "sawtooth", "triangle", "square", "random"]\n      });\n      \n      this.createInput({\n        name: "period", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "amplitude", \n        runtime: "Animation"\n      });\n      \n      this.createInput({\n        name: "offset", \n        runtime: "Animation"\n      });\n      \n      this.createInput({\n        name: "phase", \n        runtime: "Animation"\n      });\n      \n      this.createOutput({\n        name: "output",\n        runtime: "Animation"\n      });\n    },\n    \n    createViewAndEventListeners: function() {\n      \n      var view = new LFOView({\n        node: this\n      });\n      \n      this.addEventListener("attributes", function(attributes) {\n        view.setAttributes(attributes);\n      });\n    }\n  \n  };\n  \n  // View\n  // ====\n  var LFOView = function(options) {\n    this._initLFOView(options);\n  };\n  LFOView.prototype = {\n  \n    _initLFOView: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createCanvasAndAppendView();\n      \n      this.drawWaveform();\n      \n      this.$output = $("<div />");\n      this.$output.css({\n        position: "absolute",\n        bottom: 10,\n        right: 10,\n        color: "#687794"\n      });\n\n      this.appendView(this.$output[0]);\n      \n    },\n    \n    drawWaveform: function() {\n      \n    },\n    \n    setAttributes: function(attributes) {\n      \n      var output = attributes.output;\n      \n      //var max = attributes.offset + attributes.amplitude;\n      var min = attributes.offset - attributes.amplitude;\n      \n      var range = attributes.amplitude * 2;\n      \n      var width = this.context.width;\n      var height = this.context.height;\n      \n      var y_offset = 0;\n      \n      var y_padding = 30;\n      \n      var visible_height = height - y_offset - y_padding*2;\n      \n      var draw_ratio = visible_height/range;\n      \n      this.$output.text(output.toFixed(2));\n      \n      var color = "#9cd9d0";\n      \n      this.context.beginPath();\n      this.context.fillStyle = color;\n      this.context.strokeStyle = color;\n      \n      this.context.lineWidth = 1;\n      \n      this.context.arc(width-2, height-(output*draw_ratio - min*draw_ratio + y_offset + y_padding), 0.5, 0, 2 * Math.PI, false);\n      \n      this.context.lineWidth = 3;\n      \n      this.context.moveTo(width-3, this.lastY);\n      this.context.lineTo(width-3, height-(output*draw_ratio - min*draw_ratio + y_offset + y_padding));\n      // \n      // this.context.moveTo(width, output*draw_ratio - min*draw_ratio + y_offset + y_padding);\n      // this.context.lineTo(width, output*draw_ratio - min*draw_ratio + y_offset + y_padding+1);\n      // \n      this.lastY = height-(output*draw_ratio - min*draw_ratio + y_offset + y_padding);\n      \n      this.context.stroke();\n      \n      // shift everything to the left:\n      var imageData = this.context.getImageData(1, 0, this.context.canvas.width-1, this.context.canvas.height);\n      this.context.putImageData(imageData, 0, 0);\n      // now clear the right-most pixels:\n      this.context.clearRect(this.context.canvas.width-1, 0, 1, this.context.canvas.height);\n      \n    }\n    \n\n    \n  };\n\n  // Worker\n  // ======\n  var LFOWorker = function(options) {\n    this._initLFOWorker(options);\n  };\n  LFOWorker.prototype = {\n  \n    _initLFOWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n      \n      this.createAnimationInput({\n        name: "waveform",\n        default_value: 0\n      });\n      \n      this.createAnimationInput({\n        name: "period",\n        default_value: 3\n      });\n    \n      this.createAnimationInput({\n        name: "amplitude",\n        default_value: 0.5\n      });\n    \n      this.createAnimationInput({\n        name: "offset",\n        default_value: 0\n      });\n      \n      this.createAnimationInput({\n        name: "phase",\n        default_value: 0\n      });\n    \n      this.createAnimationOutput({\n        name: "output"\n      });\n    },\n  \n    runLoop: function(time, debug) {\n      \n      if (debug) {\n        console.log("LFO(" + time + ")");\n      }\n    \n      var period = parseFloat(this.inputAttributes.period) || 0.5;\n      var amplitude = parseFloat(this.inputAttributes.amplitude) || 1;\n      var offset = parseFloat(this.inputAttributes.offset) || 0;\n      var waveform = parseFloat(this.inputAttributes.waveform) || 0;\n      var phase_degrees = parseFloat(this.inputAttributes.phase) || 0;\n      var phase = phase_degrees * (Math.PI/180);\n      var pwm = 0.5;\n      \n      var output;\n      switch(waveform) {\n        case 0:\n          output = this.sine(time, period, phase);\n          break;\n        case 1:\n          output = this.sawtooth(time, period, phase);\n          break;\n        case 2:\n          output = this.triangle(time, period, phase);\n          break;\n        case 3:\n          output = this.square(time, period, phase, pwm);\n          break;\n        case 4:\n          output = this.noise();\n          break;\n      }\n      \n      //console.log("output", output);\n    \n      this.outputAttributes.output = amplitude * output + offset;\n      \n      var attributes = {};\n      \n      for (var a in this.inputAttributes) {\n        attributes[a] = this.inputAttributes[a];\n      }\n      \n      attributes.output = this.outputAttributes.output;\n      \n      this.throttledTriggerEvent({\n        name: "attributes",\n        event: attributes\n      });\n    \n    },\n    \n    sine: function(time, period, phase) { //         ~~~~~~~\n      //console.log("sine", time, period, phase);\n      return Math.sin(time/period*4+phase);\n    },\n    \n    sawtooth: function(time, period, phase) { //    /|/|/|/|/|/|/|/\n      return 2 * (time/period - Math.floor(1/2+time/period + phase));\n    },\n    \n    triangle: function(time, period, phase) { //     /\\/\\/\\/\\/\\/\\/\\/\\\n      return 2 * Math.abs(this.sawtooth(time, period, phase)) - 1;\n    },\n    \n    square: function(time, period, phase, pwm) { //     _|`|_|`|_|`|_|`|_\n      var f = time/period - Math.floor(time/period + phase);\n      if (f < pwm) {\n        return 1;\n      }\n      else {\n        return -1;\n      }\n    },\n    \n    noise: function() { //      |.\\>,\\,.\\<|,/.,\\.<|<\n      return 2 * Math.random() - 1;\n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "lfo",\n    runtime: "Animation",\n    node: LFO,\n    view: LFOView,\n    worker: LFOWorker\n  });\n  \n});\n//@ sourceURL=/nodes/lfo.js'),eval('/*global define:false */\n/*\n\n  Logger Node\n  -----------\n\n*/\n\ndefine(\'nodes/logger\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var Logger = function(options) {\n    this._initLogger(options);\n  };\n  Logger.prototype = {\n  \n    _initLogger: function(options) {\n    \n      this.callSuper(options);\n    \n      this.createInput({\n        name: "logger_in"\n      });\n    \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var LoggerWorker = function(options) {\n    this._initLoggerWorker(options);\n  };\n  LoggerWorker.prototype = { \n  \n    _initLoggerWorker: function(options) {\n    \n      this.callSuper(options);\n    \n      this.createEventInput({\n        name: "logger_in",\n        connect_point: function(event) {\n          console.log("logger: ", event);\n        }\n      });\n    \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "logger",\n    node: Logger,\n    worker: LoggerWorker\n  });\n  \n});\n//@ sourceURL=/nodes/logger.js'),eval('/*global define:false */\n/*\n\n  MathOperator Node\n  ---------------\n\n*/\n\ndefine(\'nodes/math\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var MathOperator = function(options) {\n    this._initMathOperator(options);\n  };\n  MathOperator.prototype = {\n  \n    _initMathOperator: function(options) {\n    \n      this.callSuper(options);\n    \n      this.createIO();\n\n    },\n\n    createIO: function() {\n      \n      this.createInput({\n        name: "value 1",\n        runtime: "Animation"\n      });\n      \n      this.createInput({\n        name: "operator",\n        runtime: "Animation",\n        select_options: ["+","-","*","/"]\n      });\n      \n      this.createInput({\n        name: "value 2",\n        runtime: "Animation"\n      });\n      \n      this.createOutput({\n        name: "value out",\n        runtime: "Animation"\n      });\n      \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var MathOperatorWorker = function(options) {\n    this._initMathOperatorWorker(options);\n  };\n  MathOperatorWorker.prototype = {\n  \n    _initMathOperatorWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n    \n      this.createAnimationInput({\n        name: "value 1",\n        default_value: 0\n      });\n      \n      this.createAnimationInput({\n        name: "operator",\n        default_value: "+"\n      });\n      \n      this.createAnimationInput({\n        name: "value 2",\n        default_value: 1\n      });\n      \n      this.createAnimationOutput({\n        name: "value out"\n      });\n      \n    },\n  \n    runLoop: function() {\n      \n      var out;\n      var v1 = parseFloat(this.inputAttributes["value 1"]);\n      var v2 = parseFloat(this.inputAttributes["value 2"]);\n      \n      if (this.inputAttributes.operator == "*") {\n        out = v1 * v2;\n      }\n      else if (this.inputAttributes.operator == "/") {\n        out = v1 / v2;\n      }\n      else if (this.inputAttributes.operator == "+") {\n        out = v1 + v2;\n      }\n      else if (this.inputAttributes.operator == "-") {\n        out = v1 - v2;\n      }\n      \n      this.outputAttributes["value out"] = out;\n    \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "math",\n    runtime: "Animation",\n    node: MathOperator,\n    worker: MathOperatorWorker\n  });\n  \n});\n//@ sourceURL=/nodes/math.js'),eval('/*global define:false */\n/*global $:false */\n/*global setTimeout:false */\n/*global clearTimeout:false */\n/*\n\n  MouseInput Node\n  ---------------\n\n*/\n\ndefine(\'nodes/mouse_input\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var MouseInput = function(options) {\n    this._initMouseInput(options);\n  };\n  MouseInput.prototype = {\n  \n    _initMouseInput: function(options) {\n    \n      options.height = 80;\n      this.callSuper(options);\n    \n      this.createIO();\n\n    },\n\n    createIO: function() {\n      \n      this.createOutput({\n        name: "x",\n        runtime: "Animation"\n      });\n      \n      this.createOutput({\n        name: "y",\n        runtime: "Animation"\n      });\n      \n      this.createOutput({\n        name: "moving",\n        runtime: "Animation"\n      });\n      \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var MouseInputWorker = function(options) {\n    this._initMouseInputWorker(options);\n  };\n  MouseInputWorker.prototype = {\n  \n    _initMouseInputWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n      \n      this.createEventListners();\n    \n    },\n    \n    createEventListners: function() {\n      var that = this;\n      \n      $(this.parentRuntime.element).bind("mousemove", function(evt) {\n        \n        var x = evt.offsetX || evt.originalEvent.layerX;\n        var y = evt.offsetY || evt.originalEvent.layerY;\n        \n        that.mouseMove(x, y);\n      });\n      \n    },\n    \n    createIO: function() {\n    \n      this.createAnimationOutput({\n        name: "x"\n      });\n      \n      this.createAnimationOutput({\n        name: "y"\n      });\n      \n      this.createAnimationOutput({\n        name: "moving",\n        default_value: false\n      });\n      \n    },\n    \n    mouseMove: function(x, y) {\n      this.mouseMoving = true;\n      \n      clearTimeout(this.mouseMoveTimeout);\n      \n      var that = this;\n      this.mouseMoveTimeout = setTimeout(function() {\n        that.mouseMoving = false;\n      }, 1000);\n      \n      this.xPixel = x;\n      this.yPixel = y;\n    },\n  \n    runLoop: function() {\n      \n      var ra = this.parentRuntime;\n      \n      var x = (this.xPixel/(ra._width) * 2) - 1;\n      var y = -1 * (((this.yPixel * 2) / ra._width) - (ra._height / ra._width));\n      \n      var mouseMoving = this.mouseMoving;\n      \n      this.outputAttributes.x = x;\n      this.outputAttributes.y = y;\n      \n      this.outputAttributes.mousemoving = mouseMoving;\n    \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "mouse input",\n    runtime: "Animation",\n    node: MouseInput,\n    worker: MouseInputWorker\n  });\n  \n});\n//@ sourceURL=/nodes/mouse_input.js'),eval('/*global define:false */\n/*\n\n  Oscillator Node\n  ---------------\n\n*/\n\ndefine(\'nodes/oscillator\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var Oscillator = function(options) {\n    this._initOscillator(options);\n  };\n  Oscillator.prototype = {\n  \n    _initOscillator: function(options) {\n    \n      options.fill = "#FFFFFF";\n      options.width = 70;\n      options.height = 60;\n      options.noTitle = true;\n      options.showIOLabelsWhenSelected = false;\n      \n      this.callSuper(options);\n    \n      this.createIO();\n    \n    },\n  \n    createIO: function() {\n      this.createInput({\n        y_offset: 15,\n        name: "frequency"\n      });\n    \n      this.createInput({\n        y_offset: 15,\n        name: "noteOn"\n      });\n    \n      this.createInput({\n        y_offset: 15,\n        name: "noteOff"\n      });\n    \n      this.createOutput({\n        y_offset: 30,\n        name: "audio_out",\n        runtime: "Audio"\n      });\n    }\n  \n  };\n\n  // Worker\n  // ======\n  var OscillatorWorker = function(options) {\n    this._initOscillatorWorker(options);\n  };\n  OscillatorWorker.prototype = {\n  \n    _initOscillatorWorker: function(options) {\n      this.callSuper(options);\n    \n      this.frequency = 440;\n    \n      this.outputNode = this.context.createGainNode();\n    \n      this.createIO();\n    \n      this.noteOn({\n        time: this.context.currentTime\n      });\n    \n    },\n  \n    createIO: function() {\n    \n      var that = this;\n      this.createEventInput({\n        name: "frequency", \n        connect_point: function(event) {\n          that.processFreqChange(event);\n        }\n      });\n    \n      this.createEventInput({\n        name: "noteOn", \n        connect_point: function(event) {\n          that.noteOn(event);\n        }\n      });\n    \n      this.createEventInput({\n        name: "noteOff", \n        connect_point: function(event) {\n          that.noteOff(event);\n        }\n      });\n    \n      this.createAudioOutput({\n        name: "audio_out", \n        connect_point: this.outputNode\n      });\n    },\n  \n    processFreqChange: function(event) {\n      this.frequency = event.frequency;\n      var time = event.time;\n      this.osc.frequency.setValueAtTime(this.frequency, time);\n    },\n  \n    noteOn: function(event) {\n      var time = event.time || 0;\n      if (this.osc) {\n        this.noteOff(event);\n        this.osc = null;\n      }\n      this.osc = this.context.createOscillator();\n      this.osc.type = 0;\n      this.osc.frequency.linearRampToValueAtTime(this.frequency, this.context.currentTime);\n      this.outputNode.gain.linearRampToValueAtTime(1.0, time);\n      this.osc.connect(this.outputNode);\n      this.osc.noteOn(time);\n    },\n  \n    noteOff: function(event) {\n      var time = event.time || 0;\n      if (this.osc) {\n        this.osc.frequency.cancelScheduledValues(time);\n        this.outputNode.gain.cancelScheduledValues(time);\n        this.outputNode.gain.linearRampToValueAtTime(0.0, time);\n        this.osc.noteOff(time);\n        this.osc.disconnect(this.outputNode);\n        this.osc = null;\n      }\n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "osc",\n    runtime: "Audio",\n    node: Oscillator,\n    worker: OscillatorWorker\n  });\n\n});\n//@ sourceURL=/nodes/oscillator.js'),eval('/*global define:false */\n/*global Float32Array:false */\n/*\n\n  Overdrive\n  -----------------\n\n*/\n\ndefine(\'nodes/overdrive\',[\'register_node\'], function(registerNode) {\n  \n  // Node\n  // ====\n  var Overdrive = function(options) {\n    this._initOverdriveOutput(options);\n  };\n  Overdrive.prototype = {\n  \n    _initOverdriveOutput: function(options) {\n    \n      options.width = 75;\n      options.height = 55;\n    \n      this.callSuper(options);\n    \n      this.createIO();\n    \n    },\n  \n    createIO: function() {\n    \n      this.createInput({\n        y_offset: 27.5,\n        name: "audio_in",\n        runtime: "Audio"\n      });\n      \n      this.createOutput({\n        y_offset: 27.5,\n        name: "audio_out",\n        runtime: "Audio"\n      });\n    \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var OverdriveWorker = function(options) {\n    this._initOverdriveWorker(options);\n  };\n  OverdriveWorker.prototype = {\n  \n    _initOverdriveWorker: function(options) {\n    \n      this.callSuper(options);\n\n      this.createIO();\n      \n      this.createAudioGraph();\n\n    },\n    \n    createIO: function() {\n      \n      this.inputNode = this.context.createGainNode();\n    \n      this.createAudioInput({\n        name: "audio_in",\n        connect_point: this.inputNode\n      });\n      \n      this.outputNode = this.context.createGainNode();\n    \n      this.createAudioOutput({\n        name: "audio_out",\n        connect_point: this.outputNode\n      });\n      \n    },\n    \n    createAudioGraph: function() {\n      \n      this.lowPassFreq = 3000;\n\n      this.lowPass = this.context.createBiquadFilter();\n      this.lowPass.type = 0;\n      this.lowPass.frequency.value = this.lowPassFreq;\n\n      this.waveShaper = this.context.createWaveShaper();\n\n      this.inputNode.connect(this.lowPass);\n      this.lowPass.connect(this.waveShaper);\n      this.waveShaper.connect(this.outputNode);\n      \n      this.createWSCurve(5);\n      \n    },\n    \n    createWSCurve: function(amount) {\n        var k = amount;\n        var n_samples = 22050;\n        this.wsCurve = new Float32Array(n_samples);\n        var deg = Math.PI / 180;\n        for (var i = 0; i < n_samples; i += 1) {\n            var x = i * 2 / n_samples - 1;\n            this.wsCurve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n        }\n        this.waveShaper.curve = this.wsCurve;\n    }\n    \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "overdrive",\n    alias: "od",\n    runtime: "Audio",\n    node: Overdrive,\n    worker: OverdriveWorker\n  });\n  \n});\n//@ sourceURL=/nodes/overdrive.js'),eval('/*global define:false */\n/*global XMLHttpRequest:false */\n/*\n\n  Reverb\n  -----------------\n\n*/\n\ndefine(\'nodes/reverb\',[\'register_node\'], function(registerNode) {\n  \n  // Node\n  // ====\n  var Reverb = function(options) {\n    this._initReverbOutput(options);\n  };\n  Reverb.prototype = {\n  \n    _initReverbOutput: function(options) {\n    \n      options.width = 55;\n      options.height = 55;\n    \n      this.callSuper(options);\n    \n      this.createIO();\n    \n    },\n  \n    createIO: function() {\n    \n      this.createInput({\n        y_offset: 27.5,\n        name: "audio_in",\n        runtime: "Audio"\n      });\n      \n      this.createOutput({\n        y_offset: 27.5,\n        name: "audio_out",\n        runtime: "Audio"\n      });\n    \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var ReverbWorker = function(options) {\n    this._initReverbWorker(options);\n  };\n  ReverbWorker.prototype = {\n  \n    _initReverbWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createIO();\n\n      this.createAudioGraph();\n\n    },\n    \n    createIO: function() {\n      \n      this.inputNode = this.context.createGainNode();\n    \n      this.createAudioInput({\n        name: "audio_in",\n        connect_point: this.inputNode\n      });\n      \n      this.outputNode = this.context.createGainNode();\n    \n      this.createAudioOutput({\n        name: "audio_out",\n        connect_point: this.outputNode\n      });\n      \n    },\n    \n    createAudioGraph: function() {\n      \n      this.convolver = this.context.createConvolver();\n      this.inputNode.connect(this.convolver);\n      this.convolver.connect(this.outputNode);\n      \n      this.setBufferUrl("/impulses/pcm90cleanplate.wav");\n      \n    },\n    \n    setBuffer: function(arraybuffer) {\n      var that = this;\n      this.context.decodeAudioData(arraybuffer, function(buffer) {\n        that.buffer = buffer;\n      }, null);\n    },\n\n    setBufferUrl: function(url) {\n\n      var request = new XMLHttpRequest();\n      request.open(\'GET\', url, true);\n      request.responseType = \'arraybuffer\';\n\n      var that = this;\n      request.onload = function() {\n        that.context.decodeAudioData(request.response, function(buffer) {\n          that.convolver.buffer = buffer;\n        }, null);\n      };\n      request.send();\n    }\n    \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "reverb",\n    runtime: "Audio",\n    node: Reverb,\n    worker: ReverbWorker\n  });\n  \n});\n//@ sourceURL=/nodes/reverb.js'),eval('/*global define:false */\n/*\n\n  Scale\n  -----------------\n\n*/\n\ndefine(\'nodes/scale\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var Scale = function(options) {\n    this._initScale(options);\n  };\n  Scale.prototype = {\n  \n    _initScale: function(options) {\n    \n      options.height = 100;\n      this.callSuper(options);\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n      \n      this.createInput({\n        name: "number_in"\n      });\n      \n      this.createInput({\n        name: "scale"\n      });\n      \n      this.createInput({\n        name: "offset"\n      });\n      \n      this.createOutput({\n        name: "number_out"\n      });\n      \n    }\n  \n  };\n\n  // Worker\n  // ======\n  var ScaleWorker = function(options) {\n    this._initScaleWorker(options);\n  };\n  ScaleWorker.prototype = { \n  \n    _initScaleWorker: function(options) {\n    \n      this.callSuper(options);\n      \n      this.scale = 1/220;\n      this.offset = -1.45;\n      \n      this.createIO();\n    \n    },\n    \n    createIO: function() {\n      \n      var that = this;\n      \n      this.createEventInput({\n        name: "number_in",\n        connect_point: function(event) {\n          that.processIncomingNumber(event);\n        }\n      });\n      \n      this.createEventInput({\n        name: "scale",\n        connect_point: function(event) {\n          that.scale = event;\n        }\n      });\n      \n      this.createEventInput({\n        name: "offset",\n        connect_point: function(event) {\n          that.offset = event;\n        }\n      });\n      \n      this.createEventOutput({\n        name: "number_out"\n      });\n    },\n    \n    processIncomingNumber: function(event) {\n      \n      var number_out = (event.frequency * this.scale) + this.offset;\n      \n      this.trigger({\n        source: this,\n        output_name: "number_out",\n        event: number_out\n      });\n      \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "scale",\n    alias: "s",\n    node: Scale,\n    worker: ScaleWorker\n  });\n  \n});\n//@ sourceURL=/nodes/scale.js'),eval('/*global define:false */\n/*global document:false */\n/*\n\n  Sprite Node\n  -----------\n\n*/\n\ndefine(\'nodes/sprite\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var Sprite = function(options) {\n    this._initSprite(options);\n  };\n  Sprite.prototype = {\n  \n    _initSprite: function(options) {\n      \n      this.layered = true;\n    \n      options.fill = "#FFFFFF";\n      options.height = 120;\n      \n      this.callSuper(options);\n    \n      this.createIO();\n      \n      this.createViewAndEventListeners();\n    \n    },\n  \n    createIO: function() {\n      this.createInput({\n        name: "x", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "y", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "width", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "height", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "rotation", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "color", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "image", \n        runtime: "Animation"\n      });\n      \n      // this.createInput({\n      //   name: "composite", \n      //   runtime: "Animation",\n      //   select_options: [\'source-over\',\'source-in\',\'source-out\',\'source-atop\',\'destination-over\',\'destination-in\',\'destination-out\',\'destination-atop\',\'lighter\',\'darker\',\'copy\',\'xor\']\n      // });\n      \n      this.createInput({\n        name: "alpha", \n        runtime: "Animation"\n      });\n      \n    },\n    \n    updateImageFile: function(attributes) {\n      var image_edge = this.findEdgesByInputName("image")[0];\n      \n      if (!image_edge) {\n        return;\n      }\n      \n      var image_file_node = image_edge.source;\n      \n      image_file_node.triggerEvent({\n        name: "update_width",\n        event: attributes\n      });\n      \n    },\n    \n    createViewAndEventListeners: function() {\n      \n      var that = this;\n      \n      var view = new SpriteView({\n        node: this\n      });\n      \n      this.addEventListener("attributes", function(attributes) {\n        view.setAttributes(attributes);\n        \n        if ((that.previousWidth != attributes.width) && attributes.width > 1) {\n          that.previousWidth = attributes.width;\n          that.updateImageFile(attributes);\n        }\n        \n      });\n      \n      this.$display.on("dblclick", function(){\n        that.updatePosition = !that.updatePosition;\n      });\n      \n      this.$display.on("click", function(){\n        that.updatePosition = false;\n      });\n      \n      this.$display.on("mousemove", function(event) {\n        if (that.updatePosition) {\n          that.editor.emit("updated");\n          that.triggerEvent({\n            name: "position",\n            event: {\n              x: event.offsetX,\n              y: event.offsetY\n            }\n          });\n        }\n      });\n      \n    }\n  \n  };\n  \n  // View\n  // ====\n  var SpriteView = function(options) {\n    this._initSpriteView(options);\n  };\n  SpriteView.prototype = {\n  \n    _initSpriteView: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createCanvasAndAppendView();\n      \n      this.drawXYAxis();\n      \n    },\n    \n    drawXYAxis: function() {\n      var width = this.context.width;\n      var height = this.context.height;\n      \n      this.context.clearRect(0, 0, width, height);\n      \n      this.view_ratio = 20;\n      \n      var x_y_ratio = 1.5; // 288 / 192, the animation viewer width and height\n      \n      // x/y axis\n      var xy_stroke = "#b4ddd7";\n      this.y_offset = 10;\n      // y-axis\n      var y_padding = 20;  \n      this.context.beginPath();\n      this.context.strokeStyle = xy_stroke;\n      this.context.moveTo(width/2, y_padding + this.y_offset); //\n      this.context.lineTo(width/2, height - y_padding + this.y_offset);\n      this.context.stroke();\n      \n      // x-axis\n      var x_padding = 30;\n      this.context.beginPath();\n      this.context.strokeStyle = xy_stroke;\n      this.context.moveTo(x_padding, height/2 + this.y_offset); //\n      this.context.lineTo(width - x_padding, height/2 + this.y_offset);\n      this.context.stroke();\n      \n      //draw animation viewer box\n      \n      this.context.fillStyle = "rgba(0,0,0,0.2)";\n  \n      var origin_x = width/2;\n      var origin_y = height/2 + this.y_offset;\n      \n      this.context.fillRect(origin_x - this.view_ratio, origin_y - (this.view_ratio/x_y_ratio), this.view_ratio*2, (this.view_ratio/x_y_ratio) * 2);\n      \n    },\n    \n    setAttributes: function(attributes) {\n\n      this.drawXYAxis();\n      \n      var width = this.context.width;\n      var height = this.context.height;\n      \n      var sprite_width = attributes.width * this.view_ratio;\n      var sprite_height = attributes.height * this.view_ratio;\n      \n      var origin_x = width/2 - sprite_width/2;\n      var origin_y = height/2 - sprite_height/2 + this.y_offset;\n      \n      var sprite_x = origin_x + (attributes.x * this.view_ratio);\n      var sprite_y = origin_y - (attributes.y * this.view_ratio);\n      \n      var rotation_x = sprite_x + sprite_width/2;\n      var rotation_y = sprite_y + sprite_height/2;\n      \n      this.context.save();\n      \n      this.context.translate(rotation_x, rotation_y);\n      \n      this.context.rotate(Math.PI / (180 / attributes.rotation));\n      \n      this.context.translate(-rotation_x, -rotation_y);\n      \n      this.context.fillStyle = attributes.color;\n      this.context.fillRect(sprite_x, sprite_y, sprite_width, sprite_height);\n      \n      this.context.restore();\n      \n    }\n    \n  };\n\n  // Worker\n  // ======\n  var SpriteWorker = function(options) {\n    this._initSpriteWorker(options);\n  };\n  SpriteWorker.prototype = {\n  \n    _initSpriteWorker: function(options) {\n      \n      this.layered = true;\n      \n      this.callSuper(options);\n    \n      this.createIO();\n      \n      this.createEventListeners();\n    \n    },\n  \n    createIO: function() {\n    \n      this.createAnimationInput({\n        name: "x",\n        default_value: 0\n      });\n    \n      this.createAnimationInput({\n        name: "y",\n        default_value: 0\n      });\n    \n      this.createAnimationInput({\n        name: "width",\n        default_value: 0.5\n      });\n    \n      this.createAnimationInput({\n        name: "height",\n        default_value: 0.5\n      });\n      \n      this.createAnimationInput({\n        name: "rotation",\n        default_value: 0\n      });\n    \n      this.createAnimationInput({\n        name: "color",\n        default_value: "#FFF"\n      });\n    \n      this.createAnimationInput({\n        name: "image",\n        default_value: null\n      });\n      \n      // this.createAnimationInput({\n      //   name: "composite",\n      //   default_value: "source-over"\n      // });\n      \n      this.createAnimationInput({\n        name: "alpha",\n        default_value: 1.0\n      });\n    \n    },\n    \n    createEventListeners: function() {\n      \n      var that = this;\n      \n      this.addEventListener("position", function(event) {\n        \n        var mouse_x = event.x;\n        var mouse_y = event.y;\n        \n        var x = (mouse_x/142 - 0.5) * 7.5;\n        var y = -((mouse_y/96 - 0.57) * 7.5);\n        \n        that.inputAttributes.x = x;\n        that.inputAttributes.y = y;\n        \n      });\n      \n    },\n\n    runLoop: function() {\n      \n      var x = parseFloat(this.inputAttributes.x) || 0;\n      var y = parseFloat(this.inputAttributes.y) || 0;\n      var width = parseFloat(this.inputAttributes.width) || 0.5;\n      var height = parseFloat(this.inputAttributes.height) || 0.5;\n      \n      this.throttledTriggerEvent({\n        name: "attributes",\n        event: this.inputAttributes\n      });\n    \n      var ra = this.parentRuntime;\n    \n      var t = {\n        x: ra.tX(x) - ra.tW(width/2),\n        y: ra.tY(y) - ra.tH(height/2),\n        h: ra.tH(height),\n        w: ra.tW(width)\n      };\n      \n      this.context.translate(ra.tX(x), ra.tY(y));\n      \n      this.context.rotate(Math.PI / (180 / this.inputAttributes.rotation));\n      \n      this.context.translate(-ra.tX(x), -ra.tY(y));\n      \n      this.context.globalAlpha = this.inputAttributes.alpha;\n      \n      //this.context.globalCompositeOperation = this.inputAttributes.composite;\n      \n      if (this.inputAttributes.image && this.inputAttributes.image.data) {\n        var image_data = this.inputAttributes.image;\n        var canvas = document.createElement(\'canvas\');\n        canvas.width = image_data.width;\n        canvas.height = image_data.height;\n        canvas.getContext("2d").putImageData(image_data, 0, 0);\n        this.context.drawImage(canvas, t.x, t.y, t.w, t.h);\n      }\n      else {\n        var color_string;\n        if (this.inputAttributes.color) {\n          if (typeof(this.inputAttributes.color) == "string") {\n            color_string = this.inputAttributes.color;\n          }\n          else if (typeof(this.inputAttributes.color) == "string") {\n            color_string = this.inputAttributes.color.toString();\n          }\n          \n        }\n        else {\n          color_string = "#FFF";\n        }\n        var color = color_string || "#FFF";\n        \n        if (color.indexOf("#") == -1 && color.length == 6) {\n          color = "#" + color;\n        }\n        this.context.fillStyle = color;\n        \n        this.context.fillRect(t.x, t.y, t.w, t.h);\n      }\n      \n      //this.context.globalCompositeOperation = "source-over";\n      this.context.globalAlpha = 1.0;  \n    \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "sprite",\n    alias: "s",\n    runtime: "Animation",\n    node: Sprite,\n    view: SpriteView,\n    worker: SpriteWorker\n  });\n  \n});\n//@ sourceURL=/nodes/sprite.js'),eval('/*global define:false */\n/*\n\n  Text Node\n  -----------\n\n*/\n\ndefine(\'nodes/text\',[\'register_node\'], function(registerNode) {\n\n  // Node\n  // ====\n  var Text = function(options) {\n    this._initText(options);\n  };\n  Text.prototype = {\n  \n    _initText: function(options) {\n      \n      this.layered = true;\n    \n      options.fill = "#FFFFFF";\n      options.height = 130;\n      \n      this.callSuper(options);\n    \n      this.createIO();\n      \n      this.createViewAndEventListeners();\n    \n    },\n  \n    createIO: function() {\n      this.createInput({\n        name: "string", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "x", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "y", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "font", \n        runtime: "Animation",\n        select_options: ["Impact", "Arial", "Georgia", "Tahoma", "Verdana", "Courier New", "Monaco"]\n      });\n      \n      this.createInput({\n        name: "weight", \n        runtime: "Animation",\n        select_options: ["normal", "bold"]\n      });\n      \n      this.createInput({\n        name: "size", \n        runtime: "Animation"\n      });\n    \n      this.createInput({\n        name: "color", \n        runtime: "Animation"\n      });\n    },\n    \n    createViewAndEventListeners: function() {\n      \n      var that = this;\n      \n      var view = new TextView({\n        node: this\n      });\n      \n      this.addEventListener("attributes", function(attributes) {\n        view.setAttributes(attributes);\n      });\n      \n      this.$display.on("dblclick", function(){\n        that.updatePosition = !that.updatePosition;\n      });\n      \n      this.$display.on("click", function(){\n        that.updatePosition = false;\n      });\n      \n      this.$display.on("mousemove", function(event) {\n        if (that.updatePosition) {\n          that.editor.emit("updated");\n          that.triggerEvent({\n            name: "position",\n            event: {\n              x: event.offsetX,\n              y: event.offsetY\n            }\n          });\n        }\n      });\n      \n    }\n  \n  };\n  \n  // View\n  // ====\n  var TextView = function(options) {\n    this._initTextView(options);\n  };\n  TextView.prototype = {\n  \n    _initTextView: function(options) {\n    \n      this.callSuper(options);\n      \n      this.createCanvasAndAppendView();\n      \n      this.drawXYAxis();\n      \n    },\n    \n    drawXYAxis: function() {\n      var width = this.context.width;\n      var height = this.context.height;\n      \n      this.context.clearRect(0, 0, width, height);\n      \n      this.view_ratio = 20;\n      \n      var x_y_ratio = 1.5; // 288 / 192, the animation viewer width and height\n      \n      // x/y axis\n      var xy_stroke = "#b4ddd7";\n      this.y_offset = 10;\n      // y-axis\n      var y_padding = 20;  \n      this.context.beginPath();\n      this.context.strokeStyle = xy_stroke;\n      this.context.moveTo(width/2, y_padding + this.y_offset); //\n      this.context.lineTo(width/2, height - y_padding + this.y_offset);\n      this.context.stroke();\n      \n      // x-axis\n      var x_padding = 30;\n      this.context.beginPath();\n      this.context.strokeStyle = xy_stroke;\n      this.context.moveTo(x_padding, height/2 + this.y_offset); //\n      this.context.lineTo(width - x_padding, height/2 + this.y_offset);\n      this.context.stroke();\n      \n      //draw animation viewer box\n      \n      this.context.fillStyle = "rgba(0,0,0,0.2)";\n  \n      var origin_x = width/2;\n      var origin_y = height/2 + this.y_offset;\n      \n      this.context.fillRect(origin_x - this.view_ratio, origin_y - (this.view_ratio/x_y_ratio), this.view_ratio*2, (this.view_ratio/x_y_ratio) * 2);\n      \n    },\n    \n    setAttributes: function(attributes) {\n      \n      this.drawXYAxis();\n      \n      var width = this.context.width;\n      var height = this.context.height;\n\n      this.context.fillText("test", 0, 0);\n      \n      var sprite_width = 10;\n      var sprite_height = 10;\n      \n      var origin_x = width/2 - sprite_width/2;\n      var origin_y = height/2 - sprite_height/2 + this.y_offset;\n      \n      var sprite_x = origin_x + (attributes.x * this.view_ratio);\n      var sprite_y = origin_y - (attributes.y * this.view_ratio);\n      \n      this.context.fillStyle = attributes.color;\n      this.context.fillRect(sprite_x, sprite_y, sprite_width, sprite_height);\n      \n    }\n    \n  };\n\n  // Worker\n  // ======\n  var TextWorker = function(options) {\n    this._initTextWorker(options);\n  };\n  TextWorker.prototype = {\n  \n    _initTextWorker: function(options) {\n      \n      this.layered = true;\n      \n      this.callSuper(options);\n    \n      this.createIO();\n      \n      this.createEventListeners();\n      \n    },\n  \n    createIO: function() {\n      \n      this.createAnimationInput({\n        name: "string",\n        default_value: "Hello, World!"\n      });\n    \n      this.createAnimationInput({\n        name: "x",\n        default_value: 0\n      });\n    \n      this.createAnimationInput({\n        name: "y",\n        default_value: 0\n      });\n    \n      this.createAnimationInput({\n        name: "font",\n        default_value: "Impact"\n      });\n      \n      this.createAnimationInput({\n        name: "weight",\n        default_value: "normal"\n      });\n      \n      this.createAnimationInput({\n        name: "size",\n        default_value: 0.2\n      });\n    \n      this.createAnimationInput({\n        name: "color",\n        default_value: "#FFF"\n      });\n    \n    },\n    \n    createEventListeners: function() {\n      \n      var that = this;\n      \n      this.addEventListener("position", function(event) {\n        \n        var mouse_x = event.x;\n        var mouse_y = event.y;\n        \n        var x = (mouse_x/142 - 0.5) * 7.5;\n        var y = -((mouse_y/96 - 0.57) * 7.5);\n        \n        that.inputAttributes.x = x;\n        that.inputAttributes.y = y;\n        \n      });\n      \n    },\n\n    runLoop: function() {\n      \n      var x = parseFloat(this.inputAttributes.x) || 0;\n      var y = parseFloat(this.inputAttributes.y) || 0;\n      \n      if (!this.inputAttributes.string) {\n        this.inputAttributes.string = "";\n      }\n      if (!this.inputAttributes.font) {\n        this.inputAttributes.font = "Impact";\n      }\n      if (!this.inputAttributes.weight) {\n        this.inputAttributes.weight = "normal";\n      }\n      if (!this.inputAttributes.size) {\n        this.inputAttributes.size = 0.2;\n      }\n      if (!this.inputAttributes.color) {\n        this.inputAttributes.color = "#FFF";\n      }\n      \n      this.throttledTriggerEvent({\n        name: "attributes",\n        event: this.inputAttributes\n      });\n      \n      var string = this.inputAttributes.string.toString();\n      var font = this.inputAttributes.font.toString();\n      var weight = this.inputAttributes.weight.toString();\n      var size = parseFloat(this.inputAttributes.size);\n      \n      var color_string;\n      if (this.inputAttributes.color) {\n        if (typeof(this.inputAttributes.color) == "string") {\n          color_string = this.inputAttributes.color;\n        }\n        else if (typeof(this.inputAttributes.color) == "string") {\n          color_string = this.inputAttributes.color.toString();\n        }\n        \n      }\n      else {\n        color_string = "#FFF";\n      }\n      var color = color_string || "#FFF";\n      \n      if (color.indexOf("#") == -1 && color.length == 6) {\n        color = "#" + color;\n      }\n    \n      var ra = this.parentRuntime;\n    \n      var size_in_pixels = parseInt(ra.tH(size),10).toString() + "px";\n    \n      this.context.fillStyle = color;\n      this.context.font = [weight, size_in_pixels, font].join(" ");\n      \n      var metrics1 = this.context.measureText(string);\n      \n      var width = metrics1.width;\n      \n      var t = {\n        x: ra.tX(x) - width/2,\n        y: ra.tY(y) - 0\n      };\n      \n      this.context.fillText(string, t.x, t.y);\n    \n    }\n  \n  };\n\n  // Register\n  // ========\n  registerNode({\n    name: "text",\n    alias: "t",\n    runtime: "Animation",\n    node: Text,\n    view: TextView,\n    worker: TextWorker\n  });\n  \n});\n//@ sourceURL=/nodes/text.js'),eval("/*global define:false */\n/*\n\n  [G]raph \n  [E]ditor \n  [A]nd \n  [R]untime\n\n*/\n\ndefine('gear',[\n  // Define the GraphEditor\n  'graph_editor/graph_editor',\n  // Define the RuntimeManager\n  'runtimes/runtime_manager',\n  // Load our bookkeeper registrars\n  'graph_editor/register_core',\n  'graph_editor/register_plugin',\n  'runtimes/register_runtime', \n  'register_node',\n  // Register the core graph editor object prototypes\n  'graph_editor/core/command', \n  'graph_editor/core/comment',\n  'graph_editor/core/edge',\n  'graph_editor/core/io',\n  'graph_editor/core/node',\n  'graph_editor/core/patch',\n  'graph_editor/core/patch_node',\n  'graph_editor/core/view',\n  'graph_editor/core/view_node',\n  // Register our graph editor plugins\n  'graph_editor/plugins/command_history',\n  'graph_editor/plugins/copy_paste',\n  'graph_editor/plugins/create_edge',\n  'graph_editor/plugins/media_drop',\n  'graph_editor/plugins/new_node',\n  'graph_editor/plugins/runtime_display',\n  'graph_editor/plugins/selection_box',\n  'graph_editor/plugins/sidebar',\n  // Register our runtime environments\n  'runtimes/event',\n  'runtimes/animation',\n  'runtimes/audio',\n  //'runtimes/midi',\n  // Register our nodes\n  'nodes/audio_file',\n  'nodes/audio_input',\n  'nodes/audio_output',\n  'nodes/button',\n  'nodes/delay',\n  'nodes/event_to_animation',\n  'nodes/gate_switch',\n  'nodes/grayscale',\n  'nodes/hsla',\n  'nodes/hue_adjust',\n  'nodes/image_file',\n  'nodes/lfo',\n  'nodes/logger',\n  'nodes/math',\n  //'nodes/midi_input',\n  //'nodes/midi_note_to_freq',\n  'nodes/mouse_input',\n  //'nodes/music_keyboard',\n  'nodes/oscillator',\n  'nodes/overdrive',\n  'nodes/reverb',\n  'nodes/scale',\n  'nodes/sprite',\n  'nodes/text'\n], \nfunction(GraphEditor, RuntimeManager) {\n\n  var GEAR = {\n    graph_editor: GraphEditor,\n    runtime_manager: RuntimeManager\n  };\n  \n  return GEAR;\n  \n});\n//@ sourceURL=/gear.js")